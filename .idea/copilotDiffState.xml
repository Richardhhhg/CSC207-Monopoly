<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/entity/tiles/PropertyTile.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/entity/tiles/PropertyTile.java" />
              <option name="originalContent" value="package main.entity.tiles;&#10;&#10;import main.entity.players.rentModifier;&#10;import main.use_case.Tile;&#10;import main.entity.players.Player;&#10;import main.interface_adapter.Property.PropertyLandingHandler;&#10;&#10;/*&#10; * A purchasable board tile that can collect rent.&#10; * */&#10;public class PropertyTile extends Tile {&#10;    private final float price;&#10;    private final float rent;&#10;    private Player owner; //null if not owned&#10;&#10;    private PropertyLandingHandler landingHandler;&#10;&#10;    /**&#10;     * @param name  tile name&#10;     * @param price purchase price&#10;     * @param rent  base rent amount&#10;     */&#10;    public PropertyTile(String name, float price, float rent) {&#10;        super(name);&#10;        this.price = price;&#10;        this.rent = rent;&#10;    }&#10;&#10;    public void setLandingHandler(PropertyLandingHandler handler) {&#10;        this.landingHandler = handler;&#10;    }&#10;&#10;    /**&#10;     * @return purchase price&#10;     */&#10;    public float getPrice() {&#10;        return price;&#10;    }&#10;&#10;    /**&#10;     * @return base rent (before adjustment)&#10;     */&#10;    public float getRent() {&#10;        return rent;&#10;    }&#10;&#10;    /**&#10;     * @return true if someone owns this property&#10;     */&#10;    public boolean isOwned() {&#10;        return owner != null;&#10;    }&#10;&#10;    /**&#10;     * @return the owning player, or null if unowned&#10;     */&#10;    public Player getOwner() {&#10;        return owner;&#10;    }&#10;&#10;    /**&#10;     * When a player lands here - delegate to handler for UI concerns&#10;     */&#10;    @Override&#10;    public void onLanding(Player p) {&#10;        if (!isOwned()) {&#10;            if (landingHandler != null) {&#10;                landingHandler.handleUnownedProperty(p, this);&#10;            }&#10;            return;&#10;        }&#10;&#10;        if (p != owner) {&#10;            // Calculate rent&#10;            float finalRent = rent;&#10;            if (owner instanceof rentModifier) {&#10;                finalRent = ((rentModifier) owner).adjustRent(rent);&#10;            }&#10;&#10;            // Perform the transaction&#10;            p.deductMoney(finalRent);&#10;            owner.addMoney(finalRent);&#10;&#10;            // Notify handler about rent payment&#10;            if (landingHandler != null) {&#10;                landingHandler.handleRentPayment(p, owner, this, finalRent);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Business logic for purchasing this property&#10;     */&#10;    public boolean attemptPurchase(Player player) {&#10;        if (isOwned() || player.getMoney() &lt; price) {&#10;            return false;&#10;        }&#10;&#10;        player.buyProperty(this);&#10;        this.owner = player;&#10;        return true;&#10;    }&#10;&#10;    /**&#10;     * Sets or clears ownership.&#10;     *&#10;     * @param owned ignored; ownership is determined by non-null owner&#10;     * @param owner the new owner, or null to clear&#10;     */&#10;    public void setOwned(boolean owned, Player owner) {&#10;        this.owner = owner;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package main.entity.tiles;&#10;&#10;import main.entity.players.rentModifier;&#10;import main.use_case.Tile;&#10;import main.entity.players.Player;&#10;import main.interface_adapter.Property.PropertyPurchaseController;&#10;import main.interface_adapter.Property.RentPaymentController;&#10;&#10;/*&#10; * A purchasable board tile that can collect rent.&#10; * */&#10;public class PropertyTile extends Tile {&#10;    private final float price;&#10;    private final float rent;&#10;    private Player owner; //null if not owned&#10;&#10;    private PropertyPurchaseController purchaseController;&#10;    private RentPaymentController rentPaymentController;&#10;&#10;    /**&#10;     * @param name  tile name&#10;     * @param price purchase price&#10;     * @param rent  base rent amount&#10;     */&#10;    public PropertyTile(String name, float price, float rent) {&#10;        super(name);&#10;        this.price = price;&#10;        this.rent = rent;&#10;    }&#10;&#10;    public void setPurchaseController(PropertyPurchaseController controller) {&#10;        this.purchaseController = controller;&#10;    }&#10;&#10;    public void setRentPaymentController(RentPaymentController controller) {&#10;        this.rentPaymentController = controller;&#10;    }&#10;&#10;    /**&#10;     * @return purchase price&#10;     */&#10;    public float getPrice() {&#10;        return price;&#10;    }&#10;&#10;    /**&#10;     * @return base rent (before adjustment)&#10;     */&#10;    public float getRent() {&#10;        return rent;&#10;    }&#10;&#10;    /**&#10;     * @return true if someone owns this property&#10;     */&#10;    public boolean isOwned() {&#10;        return owner != null;&#10;    }&#10;&#10;    /**&#10;     * @return the owning player, or null if unowned&#10;     */&#10;    public Player getOwner() {&#10;        return owner;&#10;    }&#10;&#10;    /**&#10;     * When a player lands here - delegate to specific controllers for UI concerns&#10;     */&#10;    @Override&#10;    public void onLanding(Player p) {&#10;        if (!isOwned()) {&#10;            if (purchaseController != null) {&#10;                purchaseController.handleUnownedProperty(p, this);&#10;            }&#10;            return;&#10;        }&#10;&#10;        if (p != owner) {&#10;            // Calculate rent&#10;            float finalRent = rent;&#10;            if (owner instanceof rentModifier) {&#10;                finalRent = ((rentModifier) owner).adjustRent(rent);&#10;            }&#10;&#10;            // Perform the transaction&#10;            p.deductMoney(finalRent);&#10;            owner.addMoney(finalRent);&#10;&#10;            // Notify controller about rent payment&#10;            if (rentPaymentController != null) {&#10;                rentPaymentController.handleRentPayment(p, owner, this, finalRent);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Business logic for purchasing this property&#10;     */&#10;    public boolean attemptPurchase(Player player) {&#10;        if (isOwned() || player.getMoney() &lt; price) {&#10;            return false;&#10;        }&#10;&#10;        player.buyProperty(this);&#10;        this.owner = player;&#10;        return true;&#10;    }&#10;&#10;    /**&#10;     * Sets or clears ownership.&#10;     *&#10;     * @param owned ignored; ownership is determined by non-null owner&#10;     * @param owner the new owner, or null to clear&#10;     */&#10;    public void setOwned(boolean owned, Player owner) {&#10;        this.owner = owner;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/interface_adapter/Property/PropertyController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/interface_adapter/Property/PropertyController.java" />
              <option name="originalContent" value="package main.interface_adapter.Property;&#10;&#10;import main.entity.tiles.PropertyTile;&#10;import main.entity.players.Player;&#10;import main.use_case.Property.PropertyPurchaseUseCase;&#10;import main.use_case.Property.RentPaymentUseCase;&#10;&#10;/**&#10; * Controller that handles property-related input and delegates to use cases.&#10; * Controllers should only coordinate between input and use cases, not presenters.&#10; */&#10;public class PropertyController implements PropertyLandingHandler {&#10;    private final PropertyPurchaseUseCase propertyPurchaseUseCase;&#10;    private final RentPaymentUseCase rentPaymentUseCase;&#10;&#10;    public PropertyController(PropertyPurchaseUseCase propertyPurchaseUseCase, RentPaymentUseCase rentPaymentUseCase) {&#10;        this.propertyPurchaseUseCase = propertyPurchaseUseCase;&#10;        this.rentPaymentUseCase = rentPaymentUseCase;&#10;    }&#10;&#10;    @Override&#10;    public void handleUnownedProperty(Player player, PropertyTile property) {&#10;        // Delegate to use case - controller doesn't handle business logic&#10;        propertyPurchaseUseCase.execute(player, property);&#10;    }&#10;&#10;    @Override&#10;    public void handleRentPayment(Player payer, Player owner, PropertyTile property, float rentAmount) {&#10;        // Delegate to use case - controller doesn't handle business logic&#10;        rentPaymentUseCase.execute(payer, owner, property, rentAmount);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package main.interface_adapter.Property;&#10;&#10;import main.entity.tiles.PropertyTile;&#10;import main.entity.players.Player;&#10;&#10;/**&#10; * Controller that handles property-related input and delegates to specific controllers.&#10; */&#10;public class PropertyController implements PropertyLandingHandler {&#10;    private final PropertyPurchaseController propertyPurchaseController;&#10;    private final RentPaymentController rentPaymentController;&#10;&#10;    public PropertyController(PropertyPurchaseController propertyPurchaseController, &#10;                            RentPaymentController rentPaymentController) {&#10;        this.propertyPurchaseController = propertyPurchaseController;&#10;        this.rentPaymentController = rentPaymentController;&#10;    }&#10;&#10;    @Override&#10;    public void handleUnownedProperty(Player player, PropertyTile property) {&#10;        propertyPurchaseController.execute(player, property);&#10;    }&#10;&#10;    @Override&#10;    public void handleRentPayment(Player payer, Player owner, PropertyTile property, float rentAmount) {&#10;        rentPaymentController.execute(payer, owner, property, rentAmount);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/interface_adapter/Property/PropertyLandingHandler.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/interface_adapter/Property/PropertyLandingHandler.java" />
              <option name="updatedContent" value="package main.interface_adapter.Property;&#10;&#10;import main.entity.tiles.PropertyTile;&#10;import main.entity.players.Player;&#10;&#10;/**&#10; * Interface for handling property landing events.&#10; * This follows the dependency inversion principle by allowing PropertyTile&#10; * to depend on an abstraction rather than concrete implementations.&#10; */&#10;public interface PropertyLandingHandler {&#10;    void handleUnownedProperty(Player player, PropertyTile property);&#10;    void handleRentPayment(Player payer, Player owner, PropertyTile property, float rentAmount);&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/interface_adapter/Property/PropertyPresenter.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/interface_adapter/Property/PropertyPresenter.java" />
              <option name="originalContent" value="package main.interface_adapter.Property;&#10;&#10;import main.use_case.Property.PropertyPurchaseUseCase.*;&#10;import main.use_case.Property.RentPaymentUseCase.*;&#10;import main.interface_adapter.Property.PropertyViewModel.*;&#10;&#10;/**&#10; * Presenter that creates view models for property-related UI.&#10; * No longer implements output boundary - works directly with use cases.&#10; */&#10;public class PropertyPresenter {&#10;    private PurchaseDialogViewModel currentPurchaseDialog;&#10;    private PropertyPurchasedViewModel currentPropertyPurchased;&#10;    private RentPaymentViewModel currentRentPayment;&#10;    private PurchaseResultCallback currentCallback;&#10;&#10;    public PropertyPresenter() {&#10;        // No view dependency&#10;    }&#10;&#10;    public void presentPurchaseDialog(PropertyPurchaseData data, PurchaseResultCallback callback) {&#10;        // Convert use case data to view model and store it&#10;        this.currentPurchaseDialog = new PurchaseDialogViewModel(&#10;            data.playerName,&#10;            data.playerMoney,&#10;            data.propertyName,&#10;            data.propertyPrice,&#10;            data.canAfford&#10;        );&#10;        this.currentCallback = callback;&#10;    }&#10;&#10;    public void presentPropertyPurchased(PropertyOwnershipData data) {&#10;        // Convert use case data to view model and store it&#10;        this.currentPropertyPurchased = new PropertyPurchasedViewModel(&#10;            data.propertyName,&#10;            data.ownerName,&#10;            data.newOwnerMoney&#10;        );&#10;    }&#10;&#10;    public void presentRentPayment(RentPaymentData data) {&#10;        // Convert use case data to view model and store it&#10;        this.currentRentPayment = new RentPaymentViewModel(&#10;            data.payerName,&#10;            data.ownerName,&#10;            data.propertyName,&#10;            data.rentAmount,&#10;            data.payerNewMoney,&#10;            data.ownerNewMoney&#10;        );&#10;    }&#10;&#10;    // View can call these methods to get the view models&#10;    public PurchaseDialogViewModel getPurchaseDialogViewModel() {&#10;        return currentPurchaseDialog;&#10;    }&#10;&#10;    public PropertyPurchasedViewModel getPropertyPurchasedViewModel() {&#10;        return currentPropertyPurchased;&#10;    }&#10;&#10;    public RentPaymentViewModel getRentPaymentViewModel() {&#10;        return currentRentPayment;&#10;    }&#10;&#10;    public PurchaseResultCallback getPurchaseCallback() {&#10;        return currentCallback;&#10;    }&#10;&#10;    // Clear methods for cleanup&#10;    public void clearPurchaseDialog() {&#10;        this.currentPurchaseDialog = null;&#10;        this.currentCallback = null;&#10;    }&#10;&#10;    public void clearPropertyPurchased() {&#10;        this.currentPropertyPurchased = null;&#10;    }&#10;&#10;    public void clearRentPayment() {&#10;        this.currentRentPayment = null;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package main.interface_adapter.Property;&#10;&#10;import main.use_case.Property.PropertyPurchaseOutputBoundary;&#10;import main.use_case.Property.RentPaymentOutputBoundary;&#10;import main.use_case.Property.PropertyPurchaseUseCase.*;&#10;import main.use_case.Property.RentPaymentUseCase.*;&#10;import main.interface_adapter.Property.PropertyViewModel.*;&#10;&#10;/**&#10; * Presenter that implements both output boundaries and creates view models for property-related UI.&#10; */&#10;public class PropertyPresenter implements PropertyPurchaseOutputBoundary, RentPaymentOutputBoundary {&#10;    private PurchaseDialogViewModel currentPurchaseDialog;&#10;    private PropertyPurchasedViewModel currentPropertyPurchased;&#10;    private RentPaymentViewModel currentRentPayment;&#10;    private PurchaseResultCallback currentCallback;&#10;&#10;    public PropertyPresenter() {&#10;        // No view dependency&#10;    }&#10;&#10;    @Override&#10;    public void presentPurchaseDialog(PropertyPurchaseData data, PurchaseResultCallback callback) {&#10;        // Convert use case data to view model and store it&#10;        this.currentPurchaseDialog = new PurchaseDialogViewModel(&#10;            data.playerName,&#10;            data.playerMoney,&#10;            data.propertyName,&#10;            data.propertyPrice,&#10;            data.canAfford&#10;        );&#10;        this.currentCallback = callback;&#10;    }&#10;&#10;    @Override&#10;    public void presentPropertyPurchased(PropertyOwnershipData data) {&#10;        // Convert use case data to view model and store it&#10;        this.currentPropertyPurchased = new PropertyPurchasedViewModel(&#10;            data.propertyName,&#10;            data.ownerName,&#10;            data.newOwnerMoney&#10;        );&#10;    }&#10;&#10;    @Override&#10;    public void presentRentPayment(RentPaymentData data) {&#10;        // Convert use case data to view model and store it&#10;        this.currentRentPayment = new RentPaymentViewModel(&#10;            data.payerName,&#10;            data.ownerName,&#10;            data.propertyName,&#10;            data.rentAmount,&#10;            data.payerNewMoney,&#10;            data.ownerNewMoney&#10;        );&#10;    }&#10;&#10;    // View can call these methods to get the view models&#10;    public PurchaseDialogViewModel getPurchaseDialogViewModel() {&#10;        return currentPurchaseDialog;&#10;    }&#10;&#10;    public PropertyPurchasedViewModel getPropertyPurchasedViewModel() {&#10;        return currentPropertyPurchased;&#10;    }&#10;&#10;    public RentPaymentViewModel getRentPaymentViewModel() {&#10;        return currentRentPayment;&#10;    }&#10;&#10;    public PurchaseResultCallback getPurchaseCallback() {&#10;        return currentCallback;&#10;    }&#10;&#10;    // Clear methods for cleanup&#10;    public void clearPurchaseDialog() {&#10;        this.currentPurchaseDialog = null;&#10;        this.currentCallback = null;&#10;    }&#10;&#10;    public void clearPropertyPurchased() {&#10;        this.currentPropertyPurchased = null;&#10;    }&#10;&#10;    public void clearRentPayment() {&#10;        this.currentRentPayment = null;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/interface_adapter/Property/PropertyPurchaseController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/interface_adapter/Property/PropertyPurchaseController.java" />
              <option name="originalContent" value="package main.interface_adapter.Property;&#10;&#10;import main.entity.tiles.PropertyTile;&#10;import main.entity.players.Player;&#10;import main.use_case.Property.PropertyPurchaseUseCase;&#10;&#10;public class PropertyPurchaseController {&#10;    private final PropertyPurchaseUseCase propertyPurchaseUseCase;&#10;    private final PropertyPresenter presenter;&#10;&#10;    public PropertyPurchaseController(PropertyPresenter presenter) {&#10;        this.presenter = presenter;&#10;        this.propertyPurchaseUseCase = new PropertyPurchaseUseCase();&#10;    }&#10;&#10;    public void execute(Player player, PropertyTile property) {&#10;        propertyPurchaseUseCase.execute(player, property, presenter);&#10;    }&#10;&#10;    public void handleUnownedProperty(Player player, PropertyTile property) {&#10;        execute(player, property);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package main.interface_adapter.Property;&#10;&#10;import main.entity.tiles.PropertyTile;&#10;import main.entity.players.Player;&#10;import main.use_case.Property.PropertyPurchaseUseCase;&#10;&#10;public class PropertyPurchaseController {&#10;    private final PropertyPurchaseUseCase propertyPurchaseUseCase;&#10;&#10;    public PropertyPurchaseController(PropertyPresenter presenter) {&#10;        // Inject presenter as output boundary into use case&#10;        this.propertyPurchaseUseCase = new PropertyPurchaseUseCase(presenter);&#10;    }&#10;&#10;    public void execute(Player player, PropertyTile property) {&#10;        propertyPurchaseUseCase.execute(player, property);&#10;    }&#10;&#10;    public void handleUnownedProperty(Player player, PropertyTile property) {&#10;        execute(player, property);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/interface_adapter/Property/PropertyViewInterface.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/interface_adapter/Property/PropertyViewInterface.java" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/interface_adapter/Property/PropertyViewModel.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/interface_adapter/Property/PropertyViewModel.java" />
              <option name="originalContent" value="package main.interface_adapter.Property;&#10;&#10;/**&#10; * View models for property-related UI data.&#10; * These are data containers that the presenter creates and the view consumes.&#10; */&#10;public class PropertyViewModel {&#10;&#10;    public static class PurchaseDialogViewModel {&#10;        public final String playerName;&#10;        public final float playerMoney;&#10;        public final String propertyName;&#10;        public final float propertyPrice;&#10;        public final boolean canAfford;&#10;&#10;        public PurchaseDialogViewModel(String playerName, float playerMoney, String propertyName,&#10;                                     float propertyPrice, boolean canAfford) {&#10;            this.playerName = playerName;&#10;            this.playerMoney = playerMoney;&#10;            this.propertyName = propertyName;&#10;            this.propertyPrice = propertyPrice;&#10;            this.canAfford = canAfford;&#10;        }&#10;    }&#10;&#10;    public static class PropertyPurchasedViewModel {&#10;        public final String propertyName;&#10;        public final String ownerName;&#10;        public final float newOwnerMoney;&#10;&#10;        public PropertyPurchasedViewModel(String propertyName, String ownerName, float newOwnerMoney) {&#10;            this.propertyName = propertyName;&#10;            this.ownerName = ownerName;&#10;            this.newOwnerMoney = newOwnerMoney;&#10;        }&#10;    }&#10;&#10;    public static class RentPaymentViewModel {&#10;        public final String payerName;&#10;        public final String ownerName;&#10;        public final String propertyName;&#10;        public final float rentAmount;&#10;        public final float payerNewMoney;&#10;        public final float ownerNewMoney;&#10;&#10;        public RentPaymentViewModel(String payerName, String ownerName, String propertyName,&#10;                                  float rentAmount, float payerNewMoney, float ownerNewMoney) {&#10;            this.payerName = payerName;&#10;            this.ownerName = ownerName;&#10;            this.propertyName = propertyName;&#10;            this.rentAmount = rentAmount;&#10;            this.payerNewMoney = payerNewMoney;&#10;            this.ownerNewMoney = ownerNewMoney;&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package main.interface_adapter.Property;&#10;&#10;/**&#10; * View models for property-related UI data.&#10; * These are data containers that the presenter creates and the view consumes.&#10; */&#10;public class PropertyViewModel {&#10;&#10;    public static class PurchaseDialogViewModel {&#10;        public final String playerName;&#10;        public final float playerMoney;&#10;        public final String propertyName;&#10;        public final float propertyPrice;&#10;        public final boolean canAfford;&#10;&#10;        public PurchaseDialogViewModel(String playerName, float playerMoney, String propertyName,&#10;                                     float propertyPrice, boolean canAfford) {&#10;            this.playerName = playerName;&#10;            this.playerMoney = playerMoney;&#10;            this.propertyName = propertyName;&#10;            this.propertyPrice = propertyPrice;&#10;            this.canAfford = canAfford;&#10;        }&#10;    }&#10;&#10;    public static class PropertyPurchasedViewModel {&#10;        public final String propertyName;&#10;        public final String ownerName;&#10;        public final float newOwnerMoney;&#10;&#10;        public PropertyPurchasedViewModel(String propertyName, String ownerName, float newOwnerMoney) {&#10;            this.propertyName = propertyName;&#10;            this.ownerName = ownerName;&#10;            this.newOwnerMoney = newOwnerMoney;&#10;        }&#10;    }&#10;&#10;    public static class RentPaymentViewModel {&#10;        public final String payerName;&#10;        public final String ownerName;&#10;        public final String propertyName;&#10;        public final float rentAmount;&#10;        public final float payerNewMoney;&#10;        public final float ownerNewMoney;&#10;&#10;        public RentPaymentViewModel(String payerName, String ownerName, String propertyName,&#10;                                  float rentAmount, float payerNewMoney, float ownerNewMoney) {&#10;            this.payerName = payerName;&#10;            this.ownerName = ownerName;&#10;            this.propertyName = propertyName;&#10;            this.rentAmount = rentAmount;&#10;            this.payerNewMoney = payerNewMoney;&#10;            this.ownerNewMoney = ownerNewMoney;&#10;        }&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/interface_adapter/Property/RentPaymentController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/interface_adapter/Property/RentPaymentController.java" />
              <option name="originalContent" value="package main.interface_adapter.Property;&#10;&#10;import main.entity.tiles.PropertyTile;&#10;import main.entity.players.Player;&#10;import main.use_case.Property.RentPaymentUseCase;&#10;&#10;public class RentPaymentController {&#10;    private final RentPaymentUseCase rentPaymentUseCase;&#10;    private final PropertyPresenter presenter;&#10;&#10;    public RentPaymentController(PropertyPresenter presenter) {&#10;        this.presenter = presenter;&#10;        this.rentPaymentUseCase = new RentPaymentUseCase();&#10;    }&#10;&#10;    public void execute(Player payer, Player owner, PropertyTile property, float rentAmount) {&#10;        rentPaymentUseCase.execute(payer, owner, property, rentAmount, presenter);&#10;    }&#10;&#10;    public void handleRentPayment(Player payer, Player owner, PropertyTile property, float rentAmount) {&#10;        execute(payer, owner, property, rentAmount);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package main.interface_adapter.Property;&#10;&#10;import main.entity.tiles.PropertyTile;&#10;import main.entity.players.Player;&#10;import main.use_case.Property.RentPaymentUseCase;&#10;&#10;public class RentPaymentController {&#10;    private final RentPaymentUseCase rentPaymentUseCase;&#10;&#10;    public RentPaymentController(PropertyPresenter presenter) {&#10;        // Inject presenter as output boundary into use case&#10;        this.rentPaymentUseCase = new RentPaymentUseCase(presenter);&#10;    }&#10;&#10;    public void execute(Player payer, Player owner, PropertyTile property, float rentAmount) {&#10;        rentPaymentUseCase.execute(payer, owner, property, rentAmount);&#10;    }&#10;&#10;    public void handleRentPayment(Player payer, Player owner, PropertyTile property, float rentAmount) {&#10;        execute(payer, owner, property, rentAmount);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/use_case/Property/PropertyLandingOutputBoundary.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/use_case/Property/PropertyLandingOutputBoundary.java" />
              <option name="updatedContent" value="package main.use_case.Property;&#10;&#10;import main.use_case.Property.PropertyLandingUseCase.*;&#10;&#10;/**&#10; * Output boundary interface for property landing use case.&#10; * Presenters implement this to receive data from the use case.&#10; */&#10;public interface PropertyLandingOutputBoundary {&#10;    void presentPurchaseDialog(PropertyPurchaseData data, PurchaseResultCallback callback);&#10;    void presentPropertyPurchased(PropertyOwnershipData data);&#10;    void presentRentPayment(RentPaymentData data);&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/use_case/Property/PropertyLandingUseCase.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/use_case/Property/PropertyLandingUseCase.java" />
              <option name="updatedContent" value="package main.use_case.Property;&#10;&#10;import main.entity.tiles.PropertyTile;&#10;import main.entity.players.Player;&#10;&#10;/**&#10; * Use case for handling property landing events.&#10; * This contains the business logic and coordinates with the presenter through an interface.&#10; */&#10;public class PropertyLandingUseCase {&#10;    private final PropertyLandingOutputBoundary presenter;&#10;&#10;    public PropertyLandingUseCase(PropertyLandingOutputBoundary presenter) {&#10;        this.presenter = presenter;&#10;    }&#10;&#10;    public void handleUnownedProperty(Player player, PropertyTile property) {&#10;        // Business logic: Validate property can be purchased&#10;        if (property.isOwned()) {&#10;            return; // Should not happen, but safety check&#10;        }&#10;&#10;        // Create data transfer object for presenter&#10;        PropertyPurchaseData purchaseData = new PropertyPurchaseData(&#10;            player.getName(),&#10;            player.getMoney(),&#10;            property.getName(),&#10;            property.getPrice(),&#10;            player.getMoney() &gt;= property.getPrice()&#10;        );&#10;&#10;        // Send to presenter through output boundary&#10;        presenter.presentPurchaseDialog(purchaseData, (success) -&gt; {&#10;            if (success) {&#10;                // Execute the purchase&#10;                boolean purchaseSuccessful = property.attemptPurchase(player);&#10;                if (purchaseSuccessful) {&#10;                    PropertyOwnershipData ownershipData = new PropertyOwnershipData(&#10;                        property.getName(),&#10;                        player.getName(),&#10;                        player.getMoney()&#10;                    );&#10;                    presenter.presentPropertyPurchased(ownershipData);&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    public void handleRentPayment(Player payer, Player owner, PropertyTile property, float rentAmount) {&#10;        // Business logic is already handled in PropertyTile.onLanding()&#10;        // Create data transfer object for presenter&#10;        RentPaymentData rentData = new RentPaymentData(&#10;            payer.getName(),&#10;            owner.getName(),&#10;            property.getName(),&#10;            rentAmount,&#10;            payer.getMoney(),&#10;            owner.getMoney()&#10;        );&#10;&#10;        // Send to presenter through output boundary&#10;        presenter.presentRentPayment(rentData);&#10;    }&#10;&#10;    // Data transfer objects for presenter communication&#10;    public static class PropertyPurchaseData {&#10;        public final String playerName;&#10;        public final float playerMoney;&#10;        public final String propertyName;&#10;        public final float propertyPrice;&#10;        public final boolean canAfford;&#10;&#10;        public PropertyPurchaseData(String playerName, float playerMoney, String propertyName, &#10;                                  float propertyPrice, boolean canAfford) {&#10;            this.playerName = playerName;&#10;            this.playerMoney = playerMoney;&#10;            this.propertyName = propertyName;&#10;            this.propertyPrice = propertyPrice;&#10;            this.canAfford = canAfford;&#10;        }&#10;    }&#10;&#10;    public static class PropertyOwnershipData {&#10;        public final String propertyName;&#10;        public final String ownerName;&#10;        public final float newOwnerMoney;&#10;&#10;        public PropertyOwnershipData(String propertyName, String ownerName, float newOwnerMoney) {&#10;            this.propertyName = propertyName;&#10;            this.ownerName = ownerName;&#10;            this.newOwnerMoney = newOwnerMoney;&#10;        }&#10;    }&#10;&#10;    public static class RentPaymentData {&#10;        public final String payerName;&#10;        public final String ownerName;&#10;        public final String propertyName;&#10;        public final float rentAmount;&#10;        public final float payerNewMoney;&#10;        public final float ownerNewMoney;&#10;&#10;        public RentPaymentData(String payerName, String ownerName, String propertyName,&#10;                             float rentAmount, float payerNewMoney, float ownerNewMoney) {&#10;            this.payerName = payerName;&#10;            this.ownerName = ownerName;&#10;            this.propertyName = propertyName;&#10;            this.rentAmount = rentAmount;&#10;            this.payerNewMoney = payerNewMoney;&#10;            this.ownerNewMoney = ownerNewMoney;&#10;        }&#10;    }&#10;&#10;    public interface PurchaseResultCallback {&#10;        void onResult(boolean success);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/use_case/Property/PropertyPurchaseOutputBoundary.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/use_case/Property/PropertyPurchaseOutputBoundary.java" />
              <option name="updatedContent" value="package main.use_case.Property;&#10;&#10;import main.use_case.Property.PropertyPurchaseUseCase.*;&#10;&#10;/**&#10; * Output boundary interface for property purchase use case.&#10; * This interface defines what the use case expects from its presenter.&#10; */&#10;public interface PropertyPurchaseOutputBoundary {&#10;    void presentPurchaseDialog(PropertyPurchaseData data, PurchaseResultCallback callback);&#10;    void presentPropertyPurchased(PropertyOwnershipData data);&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/use_case/Property/PropertyPurchaseUseCase.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/use_case/Property/PropertyPurchaseUseCase.java" />
              <option name="originalContent" value="package main.use_case.Property;&#10;&#10;import main.entity.tiles.PropertyTile;&#10;import main.entity.players.Player;&#10;import main.interface_adapter.Property.PropertyPresenter;&#10;&#10;public class PropertyPurchaseUseCase {&#10;&#10;    public void execute(Player player, PropertyTile property, PropertyPresenter presenter) {&#10;        // Business logic: Validate property can be purchased&#10;        if (property.isOwned()) {&#10;            return; // Should not happen, but safety check&#10;        }&#10;&#10;        // Create data transfer object for presenter&#10;        PropertyPurchaseData purchaseData = new PropertyPurchaseData(&#10;            player.getName(),&#10;            player.getMoney(),&#10;            property.getName(),&#10;            property.getPrice(),&#10;            player.getMoney() &gt;= property.getPrice()&#10;        );&#10;&#10;        // Send to presenter directly&#10;        presenter.presentPurchaseDialog(purchaseData, (success) -&gt; {&#10;            if (success) {&#10;                // Execute the purchase&#10;                boolean purchaseSuccessful = property.attemptPurchase(player);&#10;                if (purchaseSuccessful) {&#10;                    PropertyOwnershipData ownershipData = new PropertyOwnershipData(&#10;                        property.getName(),&#10;                        player.getName(),&#10;                        player.getMoney()&#10;                    );&#10;                    presenter.presentPropertyPurchased(ownershipData);&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    // Data transfer objects&#10;    public static class PropertyPurchaseData {&#10;        public final String playerName;&#10;        public final float playerMoney;&#10;        public final String propertyName;&#10;        public final float propertyPrice;&#10;        public final boolean canAfford;&#10;&#10;        public PropertyPurchaseData(String playerName, float playerMoney, String propertyName,&#10;                                  float propertyPrice, boolean canAfford) {&#10;            this.playerName = playerName;&#10;            this.playerMoney = playerMoney;&#10;            this.propertyName = propertyName;&#10;            this.propertyPrice = propertyPrice;&#10;            this.canAfford = canAfford;&#10;        }&#10;    }&#10;&#10;    public static class PropertyOwnershipData {&#10;        public final String propertyName;&#10;        public final String ownerName;&#10;        public final float newOwnerMoney;&#10;&#10;        public PropertyOwnershipData(String propertyName, String ownerName, float newOwnerMoney) {&#10;            this.propertyName = propertyName;&#10;            this.ownerName = ownerName;&#10;            this.newOwnerMoney = newOwnerMoney;&#10;        }&#10;    }&#10;&#10;    public interface PurchaseResultCallback {&#10;        void onResult(boolean success);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package main.use_case.Property;&#10;&#10;import main.entity.tiles.PropertyTile;&#10;import main.entity.players.Player;&#10;&#10;public class PropertyPurchaseUseCase {&#10;    private final PropertyPurchaseOutputBoundary outputBoundary;&#10;&#10;    public PropertyPurchaseUseCase(PropertyPurchaseOutputBoundary outputBoundary) {&#10;        this.outputBoundary = outputBoundary;&#10;    }&#10;&#10;    public void execute(Player player, PropertyTile property) {&#10;        // Business logic: Validate property can be purchased&#10;        if (property.isOwned()) {&#10;            return; // Should not happen, but safety check&#10;        }&#10;&#10;        // Create data transfer object for presenter&#10;        PropertyPurchaseData purchaseData = new PropertyPurchaseData(&#10;            player.getName(),&#10;            player.getMoney(),&#10;            property.getName(),&#10;            property.getPrice(),&#10;            player.getMoney() &gt;= property.getPrice()&#10;        );&#10;&#10;        // Send to presenter through output boundary&#10;        outputBoundary.presentPurchaseDialog(purchaseData, (success) -&gt; {&#10;            if (success) {&#10;                // Execute the purchase&#10;                boolean purchaseSuccessful = property.attemptPurchase(player);&#10;                if (purchaseSuccessful) {&#10;                    PropertyOwnershipData ownershipData = new PropertyOwnershipData(&#10;                        property.getName(),&#10;                        player.getName(),&#10;                        player.getMoney()&#10;                    );&#10;                    outputBoundary.presentPropertyPurchased(ownershipData);&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    // Data transfer objects&#10;    public static class PropertyPurchaseData {&#10;        public final String playerName;&#10;        public final float playerMoney;&#10;        public final String propertyName;&#10;        public final float propertyPrice;&#10;        public final boolean canAfford;&#10;&#10;        public PropertyPurchaseData(String playerName, float playerMoney, String propertyName,&#10;                                  float propertyPrice, boolean canAfford) {&#10;            this.playerName = playerName;&#10;            this.playerMoney = playerMoney;&#10;            this.propertyName = propertyName;&#10;            this.propertyPrice = propertyPrice;&#10;            this.canAfford = canAfford;&#10;        }&#10;    }&#10;&#10;    public static class PropertyOwnershipData {&#10;        public final String propertyName;&#10;        public final String ownerName;&#10;        public final float newOwnerMoney;&#10;&#10;        public PropertyOwnershipData(String propertyName, String ownerName, float newOwnerMoney) {&#10;            this.propertyName = propertyName;&#10;            this.ownerName = ownerName;&#10;            this.newOwnerMoney = newOwnerMoney;&#10;        }&#10;    }&#10;&#10;    public interface PurchaseResultCallback {&#10;        void onResult(boolean success);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/use_case/Property/RentPaymentOutputBoundary.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/use_case/Property/RentPaymentOutputBoundary.java" />
              <option name="updatedContent" value="package main.use_case.Property;&#10;&#10;import main.use_case.Property.RentPaymentUseCase.*;&#10;&#10;/**&#10; * Output boundary interface for rent payment use case.&#10; * This interface defines what the use case expects from its presenter.&#10; */&#10;public interface RentPaymentOutputBoundary {&#10;    void presentRentPayment(RentPaymentData data);&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/use_case/Property/RentPaymentUseCase.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/use_case/Property/RentPaymentUseCase.java" />
              <option name="originalContent" value="package main.use_case.Property;&#10;&#10;import main.entity.tiles.PropertyTile;&#10;import main.entity.players.Player;&#10;import main.interface_adapter.Property.PropertyPresenter;&#10;&#10;public class RentPaymentUseCase {&#10;&#10;    public void execute(Player payer, Player owner, PropertyTile property, float rentAmount, PropertyPresenter presenter) {&#10;        // Business logic is already handled in PropertyTile.onLanding()&#10;        // Create data transfer object for presenter&#10;        RentPaymentData rentData = new RentPaymentData(&#10;            payer.getName(),&#10;            owner.getName(),&#10;            property.getName(),&#10;            rentAmount,&#10;            payer.getMoney(),&#10;            owner.getMoney()&#10;        );&#10;&#10;        // Send to presenter directly&#10;        presenter.presentRentPayment(rentData);&#10;    }&#10;&#10;    // Data transfer object&#10;    public static class RentPaymentData {&#10;        public final String payerName;&#10;        public final String ownerName;&#10;        public final String propertyName;&#10;        public final float rentAmount;&#10;        public final float payerNewMoney;&#10;        public final float ownerNewMoney;&#10;&#10;        public RentPaymentData(String payerName, String ownerName, String propertyName,&#10;                             float rentAmount, float payerNewMoney, float ownerNewMoney) {&#10;            this.payerName = payerName;&#10;            this.ownerName = ownerName;&#10;            this.propertyName = propertyName;&#10;            this.rentAmount = rentAmount;&#10;            this.payerNewMoney = payerNewMoney;&#10;            this.ownerNewMoney = ownerNewMoney;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package main.use_case.Property;&#10;&#10;import main.entity.tiles.PropertyTile;&#10;import main.entity.players.Player;&#10;&#10;public class RentPaymentUseCase {&#10;    private final RentPaymentOutputBoundary outputBoundary;&#10;&#10;    public RentPaymentUseCase(RentPaymentOutputBoundary outputBoundary) {&#10;        this.outputBoundary = outputBoundary;&#10;    }&#10;&#10;    public void execute(Player payer, Player owner, PropertyTile property, float rentAmount) {&#10;        // Business logic is already handled in PropertyTile.onLanding()&#10;        // Create data transfer object for presenter&#10;        RentPaymentData rentData = new RentPaymentData(&#10;            payer.getName(),&#10;            owner.getName(),&#10;            property.getName(),&#10;            rentAmount,&#10;            payer.getMoney(),&#10;            owner.getMoney()&#10;        );&#10;&#10;        // Send to presenter through output boundary&#10;        outputBoundary.presentRentPayment(rentData);&#10;    }&#10;&#10;    // Data transfer object&#10;    public static class RentPaymentData {&#10;        public final String payerName;&#10;        public final String ownerName;&#10;        public final String propertyName;&#10;        public final float rentAmount;&#10;        public final float payerNewMoney;&#10;        public final float ownerNewMoney;&#10;&#10;        public RentPaymentData(String payerName, String ownerName, String propertyName,&#10;                             float rentAmount, float payerNewMoney, float ownerNewMoney) {&#10;            this.payerName = payerName;&#10;            this.ownerName = ownerName;&#10;            this.propertyName = propertyName;&#10;            this.rentAmount = rentAmount;&#10;            this.payerNewMoney = payerNewMoney;&#10;            this.ownerNewMoney = ownerNewMoney;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/view/BoardView.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/view/BoardView.java" />
              <option name="originalContent" value="package main.view;&#10;&#10;import main.entity.tiles.PropertyTile;&#10;import main.entity.players.Player;&#10;import main.entity.*;&#10;import main.use_case.Game.GameNextTurn;&#10;import main.Constants.Constants;&#10;import main.use_case.Property.PropertyPurchaseUseCase;&#10;import main.use_case.Tile;&#10;import main.use_case.Game.GameMoveCurrentPlayer;&#10;import main.interface_adapter.Property.PropertyPresenter;&#10;import main.interface_adapter.Property.PropertyViewModel.*;&#10;import main.interface_adapter.Property.PropertyPurchaseController;&#10;import main.interface_adapter.Property.RentPaymentController;&#10;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;&#10;/**&#10; * BoardView is a JPanel that represents the main.view of the game board.&#10; * Note: THIS IS NOT THE ENTIRE WINDOW, just the board itself.&#10; */&#10;public class BoardView extends JPanel {&#10;    // Components responsible for specific functionality&#10;    private final Game game;&#10;    private final BoardRenderer boardRenderer;&#10;    private final DiceAnimator diceAnimator;&#10;    private final PlayerMovementAnimator playerMovementAnimator;&#10;    private JFrame parentFrame; // Reference to parent frame for end screen&#10;    private final GameMoveCurrentPlayer gameMoveCurrentPlayer;&#10;&#10;    // Controllers and Presenters following Clean Architecture&#10;    private final PropertyPresenter propertyPresenter;&#10;    private final PropertyPurchaseController propertyPurchaseController;&#10;    private final RentPaymentController rentPaymentController;&#10;&#10;    // ——— Dice UI &amp; state ———&#10;    private final JButton rollDiceButton = new JButton(&quot;Roll Dice&quot;);&#10;    private final JButton endTurnButton = new JButton(&quot;End Turn&quot;);&#10;    private final JButton stockMarketButton = new JButton(&quot;Stock Market&quot;);&#10;    private final JLabel roundLabel = new JLabel(&quot;Round: 1&quot;);&#10;    private final JLabel turnLabel = new JLabel(&quot;Turns: 0&quot;);&#10;&#10;    // player stats&#10;    private final PlayerStatsView statsPanel;&#10;&#10;    public BoardView() {&#10;        this.game = new Game();&#10;        this.diceAnimator = new DiceAnimator();&#10;        this.boardRenderer = new BoardRenderer();&#10;        this.playerMovementAnimator = new PlayerMovementAnimator();&#10;        this.statsPanel = new PlayerStatsView(game.getPlayers());&#10;        this.gameMoveCurrentPlayer = new GameMoveCurrentPlayer(game);&#10;&#10;        // Initialize Clean Architecture components in proper order&#10;        this.propertyPresenter = new PropertyPresenter();&#10;&#10;        // Controllers act as interactors and depend on presenter&#10;        this.propertyPurchaseController = new PropertyPurchaseController(propertyPresenter);&#10;        this.rentPaymentController = new RentPaymentController(propertyPresenter);&#10;&#10;        // Set controllers directly as the landing handlers for all property tiles&#10;        setupPropertyLandingHandlers();&#10;&#10;        setPreferredSize(new java.awt.Dimension(Constants.BOARD_PANEL_WIDTH,&#10;                Constants.BOARD_PANEL_HEIGHT));&#10;        setupUI();&#10;    }&#10;&#10;    /**&#10;     * Configure property tiles to use the specific controllers directly&#10;     */&#10;    private void setupPropertyLandingHandlers() {&#10;        for (PropertyTile property : game.getTiles()) {&#10;            property.setPurchaseController(propertyPurchaseController);&#10;            property.setRentPaymentController(rentPaymentController);&#10;        }&#10;    }&#10;&#10;    public void setParentFrame(JFrame parentFrame) {&#10;        this.parentFrame = parentFrame;&#10;    }&#10;&#10;    private void setupUI() {&#10;        setLayout(new BorderLayout());&#10;        setPreferredSize(new Dimension(Constants.BOARD_PANEL_WIDTH, Constants.BOARD_PANEL_HEIGHT));&#10;&#10;        // Create board panel&#10;        JPanel boardPanel = new JPanel() {&#10;            @Override&#10;            protected void paintComponent(Graphics g) {&#10;                super.paintComponent(g);&#10;                boardRenderer.drawBoard(g, game, diceAnimator);&#10;            }&#10;        };&#10;        boardPanel.setPreferredSize(new Dimension(Constants.BOARD_PANEL_WIDTH, Constants.BOARD_PANEL_HEIGHT));&#10;        boardPanel.setBackground(Color.LIGHT_GRAY);&#10;&#10;        add(boardPanel, BorderLayout.WEST);&#10;        add(statsPanel, BorderLayout.CENTER);&#10;&#10;        // Roll-Dice side-panel&#10;        JPanel side = new JPanel();&#10;        side.setLayout(new BoxLayout(side, BoxLayout.Y_AXIS));&#10;&#10;        // Game status labels&#10;        roundLabel.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 16));&#10;        turnLabel.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 16));&#10;        side.add(roundLabel);&#10;        side.add(turnLabel);&#10;        side.add(Box.createVerticalStrut(20));&#10;&#10;        side.add(rollDiceButton);&#10;        side.add(endTurnButton);&#10;        side.add(stockMarketButton);&#10;        add(side, BorderLayout.EAST);&#10;&#10;        // wire the button&#10;        rollDiceButton.addActionListener(e -&gt; handleRollDice());&#10;        endTurnButton.addActionListener(e -&gt; handleEndTurn());&#10;        stockMarketButton.addActionListener(e -&gt; displayStockMarket());&#10;&#10;        updateStatusLabels();&#10;    }&#10;&#10;    /**&#10;     * Delegate stock market display to appropriate component&#10;     */&#10;    private void displayStockMarket() {&#10;        StockMarketView stockMarketView = new StockMarketView(game.getCurrentPlayer());&#10;        stockMarketView.setVisible(true);&#10;    }&#10;&#10;    /**&#10;     * Update game status display&#10;     */&#10;    private void updateStatusLabels() {&#10;        roundLabel.setText(&quot;Round: &quot; + game.getCurrentRound());&#10;        turnLabel.setText(&quot;Turns: &quot; + game.getTotalTurns());&#10;    }&#10;&#10;    /**&#10;     * Handle dice roll - delegate to DiceController&#10;     */&#10;    private void handleRollDice() {&#10;        rollDiceButton.setEnabled(false);&#10;&#10;        // Use DiceController for dice animation and logic&#10;        diceAnimator.startDiceAnimation(&#10;            this::repaint, // Animation frame callback&#10;            this::onDiceRollComplete // Completion callback&#10;        );&#10;    }&#10;&#10;    /**&#10;     * Handle dice roll completion - delegate movement to game logic&#10;     */&#10;    private void onDiceRollComplete() {&#10;        Player currentPlayer = game.getCurrentPlayer();&#10;        int diceSum = diceAnimator.getLastDiceSum();&#10;&#10;        // Handle crossing GO bonus using GameBoard logic&#10;        gameMoveCurrentPlayer.execute(diceSum);&#10;&#10;        // Use PlayerMovementAnimator for movement animation&#10;        playerMovementAnimator.animatePlayerMovement(&#10;            currentPlayer,&#10;            diceSum,&#10;            game.getTileCount(),&#10;            this::repaint, // Movement step callback&#10;            this::onPlayerMovementComplete // Completion callback&#10;        );&#10;    }&#10;&#10;    /**&#10;     * Handle player movement completion - delegate to tile logic&#10;     */&#10;    private void onPlayerMovementComplete() {&#10;        handleLandingOnTile();&#10;    }&#10;&#10;    /**&#10;     * Handle landing on tile - delegate to tile's onLanding method&#10;     * The tile will use the appropriate controller (PropertyController for properties)&#10;     */&#10;    private void handleLandingOnTile() {&#10;        Player currentPlayer = game.getCurrentPlayer();&#10;        int position = currentPlayer.getPosition();&#10;        Tile tile = game.getPropertyAt(position);&#10;&#10;        if (tile != null) {&#10;            // Use tile's built-in landing logic which will call the appropriate controller&#10;            tile.onLanding(currentPlayer);&#10;&#10;            // Check if presenter has any view models to display&#10;            checkForPresenterUpdates();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Check if the presenter has any view models ready and display them&#10;     */&#10;    private void checkForPresenterUpdates() {&#10;        // Check for purchase dialog&#10;        PurchaseDialogViewModel purchaseDialog = propertyPresenter.getPurchaseDialogViewModel();&#10;        if (purchaseDialog != null) {&#10;            PropertyPurchaseUseCase.PurchaseResultCallback callback = propertyPresenter.getPurchaseCallback();&#10;            showPurchaseDialog(purchaseDialog, callback);&#10;            propertyPresenter.clearPurchaseDialog();&#10;        }&#10;&#10;        // Check for property purchased notification&#10;        PropertyPurchasedViewModel propertyPurchased = propertyPresenter.getPropertyPurchasedViewModel();&#10;        if (propertyPurchased != null) {&#10;            updateAfterPropertyPurchased(propertyPurchased);&#10;            propertyPresenter.clearPropertyPurchased();&#10;        }&#10;&#10;        // Check for rent payment notification&#10;        RentPaymentViewModel rentPayment = propertyPresenter.getRentPaymentViewModel();&#10;        if (rentPayment != null) {&#10;            showRentPaymentNotification(rentPayment);&#10;            propertyPresenter.clearRentPayment();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle end turn - delegate to game logic&#10;     */&#10;    private void handleEndTurn() {&#10;        new GameNextTurn(game).execute();&#10;        updateStatusLabels();&#10;        statsPanel.updatePlayers(game.getPlayers());&#10;&#10;        if (game.isGameOver()) {&#10;            showEndScreen();&#10;            return;&#10;        }&#10;&#10;        rollDiceButton.setEnabled(true);&#10;        repaint();&#10;    }&#10;&#10;    /**&#10;     * Show end screen when game is over&#10;     */&#10;    private void showEndScreen() {&#10;        rollDiceButton.setEnabled(false);&#10;        endTurnButton.setEnabled(false);&#10;&#10;        // Hide the parent frame if it exists&#10;        if (parentFrame != null) {&#10;            parentFrame.setVisible(false);&#10;        }&#10;&#10;        // Show the end screen&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            new EndScreen(&#10;                    game.getPlayers(),&#10;                    game.getGameEndReason(),&#10;                    game.getCurrentRound()&#10;            );&#10;        });&#10;    }&#10;&#10;    public int getLastDiceSum() {&#10;        return diceAnimator.getLastDiceSum();&#10;    }&#10;&#10;    /**&#10;     * For Testing the Board View on its own&#10;     */&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            JFrame frame = new JFrame(&quot;Monopoly Board&quot;);&#10;            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;            BoardView boardView = new BoardView();&#10;            boardView.setParentFrame(frame);&#10;            frame.add(boardView);&#10;            frame.pack();&#10;            frame.setLocationRelativeTo(null);&#10;            frame.setVisible(true);&#10;        });&#10;    }&#10;&#10;    // Property-related view methods (now work with view models only)&#10;    public void showPurchaseDialog(PurchaseDialogViewModel viewModel, PurchaseResultCallback callback) {&#10;        Frame parentFrame = (Frame) SwingUtilities.getWindowAncestor(this);&#10;&#10;        // Find the actual player and property objects for the popup&#10;        Player player = findPlayerByName(viewModel.playerName);&#10;        PropertyTile property = findPropertyByName(viewModel.propertyName);&#10;&#10;        if (player != null &amp;&amp; property != null) {&#10;            BuyPropertyPopup.showPurchaseDialog(parentFrame, player, property,&#10;                    (success, message) -&gt; callback.onResult(success));&#10;        }&#10;    }&#10;&#10;    public void updateAfterPropertyPurchased(PropertyPurchasedViewModel viewModel) {&#10;        // Update UI after property purchase&#10;        statsPanel.updatePlayers(game.getPlayers());&#10;        repaint(); // Trigger board repaint to show ownership change&#10;    }&#10;&#10;    public void showRentPaymentNotification(RentPaymentViewModel viewModel) {&#10;        // Show rent payment notification&#10;        Frame parentFrame = (Frame) SwingUtilities.getWindowAncestor(this);&#10;        showRentNotification(parentFrame, viewModel);&#10;&#10;        // Update UI after rent payment&#10;        statsPanel.updatePlayers(game.getPlayers());&#10;        repaint();&#10;    }&#10;&#10;    // Helper methods for finding entities (needed for legacy popup interface)&#10;    private Player findPlayerByName(String name) {&#10;        return game.getPlayers().stream()&#10;                .filter(p -&gt; p.getName().equals(name))&#10;                .findFirst()&#10;                .orElse(null);&#10;    }&#10;&#10;    private PropertyTile findPropertyByName(String name) {&#10;        return game.getTiles().stream()&#10;                .filter(tile -&gt; tile.getName().equals(name))&#10;                .findFirst()&#10;                .orElse(null);&#10;    }&#10;&#10;    /**&#10;     * Shows rent payment notification dialog using view model data&#10;     */&#10;    private void showRentNotification(Frame parent, RentPaymentViewModel viewModel) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            String message = viewModel.payerName + &quot; paid $&quot; + (int) viewModel.rentAmount +&#10;                    &quot; rent to &quot; + viewModel.ownerName + &quot; for landing on &quot; + viewModel.propertyName;&#10;&#10;            JOptionPane.showMessageDialog(&#10;                    parent,&#10;                    message,&#10;                    &quot;Rent Payment&quot;,&#10;                    JOptionPane.INFORMATION_MESSAGE&#10;            );&#10;        });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package main.view;&#10;&#10;import main.entity.tiles.PropertyTile;&#10;import main.entity.players.Player;&#10;import main.entity.*;&#10;import main.use_case.Game.GameNextTurn;&#10;import main.Constants.Constants;&#10;import main.use_case.Property.PropertyPurchaseUseCase;&#10;import main.use_case.Tile;&#10;import main.use_case.Game.GameMoveCurrentPlayer;&#10;import main.interface_adapter.Property.PropertyPresenter;&#10;import main.interface_adapter.Property.PropertyViewModel.*;&#10;import main.interface_adapter.Property.PropertyPurchaseController;&#10;import main.interface_adapter.Property.RentPaymentController;&#10;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;&#10;/**&#10; * BoardView is a JPanel that represents the main.view of the game board.&#10; * Note: THIS IS NOT THE ENTIRE WINDOW, just the board itself.&#10; */&#10;public class BoardView extends JPanel {&#10;    // Components responsible for specific functionality&#10;    private final Game game;&#10;    private final BoardRenderer boardRenderer;&#10;    private final DiceAnimator diceAnimator;&#10;    private final PlayerMovementAnimator playerMovementAnimator;&#10;    private JFrame parentFrame; // Reference to parent frame for end screen&#10;    private final GameMoveCurrentPlayer gameMoveCurrentPlayer;&#10;&#10;    // Controllers and Presenters following Clean Architecture&#10;    private final PropertyPresenter propertyPresenter;&#10;    private final PropertyPurchaseController propertyPurchaseController;&#10;    private final RentPaymentController rentPaymentController;&#10;&#10;    // ——— Dice UI &amp; state ———&#10;    private final JButton rollDiceButton = new JButton(&quot;Roll Dice&quot;);&#10;    private final JButton endTurnButton = new JButton(&quot;End Turn&quot;);&#10;    private final JButton stockMarketButton = new JButton(&quot;Stock Market&quot;);&#10;    private final JLabel roundLabel = new JLabel(&quot;Round: 1&quot;);&#10;    private final JLabel turnLabel = new JLabel(&quot;Turns: 0&quot;);&#10;&#10;    // player stats&#10;    private final PlayerStatsView statsPanel;&#10;&#10;    public BoardView() {&#10;        this.game = new Game();&#10;        this.diceAnimator = new DiceAnimator();&#10;        this.boardRenderer = new BoardRenderer();&#10;        this.playerMovementAnimator = new PlayerMovementAnimator();&#10;        this.statsPanel = new PlayerStatsView(game.getPlayers());&#10;        this.gameMoveCurrentPlayer = new GameMoveCurrentPlayer(game);&#10;&#10;        // Initialize Clean Architecture components in proper order&#10;        this.propertyPresenter = new PropertyPresenter();&#10;&#10;        // Controllers act as interactors and depend on presenter&#10;        this.propertyPurchaseController = new PropertyPurchaseController(propertyPresenter);&#10;        this.rentPaymentController = new RentPaymentController(propertyPresenter);&#10;&#10;        // Set controllers directly as the landing handlers for all property tiles&#10;        setupPropertyLandingHandlers();&#10;&#10;        setPreferredSize(new java.awt.Dimension(Constants.BOARD_PANEL_WIDTH,&#10;                Constants.BOARD_PANEL_HEIGHT));&#10;        setupUI();&#10;    }&#10;&#10;    /**&#10;     * Configure property tiles to use the specific controllers directly&#10;     */&#10;    private void setupPropertyLandingHandlers() {&#10;        for (PropertyTile property : game.getTiles()) {&#10;            property.setPurchaseController(propertyPurchaseController);&#10;            property.setRentPaymentController(rentPaymentController);&#10;        }&#10;    }&#10;&#10;    public void setParentFrame(JFrame parentFrame) {&#10;        this.parentFrame = parentFrame;&#10;    }&#10;&#10;    private void setupUI() {&#10;        setLayout(new BorderLayout());&#10;        setPreferredSize(new Dimension(Constants.BOARD_PANEL_WIDTH, Constants.BOARD_PANEL_HEIGHT));&#10;&#10;        // Create board panel&#10;        JPanel boardPanel = new JPanel() {&#10;            @Override&#10;            protected void paintComponent(Graphics g) {&#10;                super.paintComponent(g);&#10;                boardRenderer.drawBoard(g, game, diceAnimator);&#10;            }&#10;        };&#10;        boardPanel.setPreferredSize(new Dimension(Constants.BOARD_PANEL_WIDTH, Constants.BOARD_PANEL_HEIGHT));&#10;        boardPanel.setBackground(Color.LIGHT_GRAY);&#10;&#10;        add(boardPanel, BorderLayout.WEST);&#10;        add(statsPanel, BorderLayout.CENTER);&#10;&#10;        // Roll-Dice side-panel&#10;        JPanel side = new JPanel();&#10;        side.setLayout(new BoxLayout(side, BoxLayout.Y_AXIS));&#10;&#10;        // Game status labels&#10;        roundLabel.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 16));&#10;        turnLabel.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 16));&#10;        side.add(roundLabel);&#10;        side.add(turnLabel);&#10;        side.add(Box.createVerticalStrut(20));&#10;&#10;        side.add(rollDiceButton);&#10;        side.add(endTurnButton);&#10;        side.add(stockMarketButton);&#10;        add(side, BorderLayout.EAST);&#10;&#10;        // wire the button&#10;        rollDiceButton.addActionListener(e -&gt; handleRollDice());&#10;        endTurnButton.addActionListener(e -&gt; handleEndTurn());&#10;        stockMarketButton.addActionListener(e -&gt; displayStockMarket());&#10;&#10;        updateStatusLabels();&#10;    }&#10;&#10;    /**&#10;     * Delegate stock market display to appropriate component&#10;     */&#10;    private void displayStockMarket() {&#10;        StockMarketView stockMarketView = new StockMarketView(game.getCurrentPlayer());&#10;        stockMarketView.setVisible(true);&#10;    }&#10;&#10;    /**&#10;     * Update game status display&#10;     */&#10;    private void updateStatusLabels() {&#10;        roundLabel.setText(&quot;Round: &quot; + game.getCurrentRound());&#10;        turnLabel.setText(&quot;Turns: &quot; + game.getTotalTurns());&#10;    }&#10;&#10;    /**&#10;     * Handle dice roll - delegate to DiceController&#10;     */&#10;    private void handleRollDice() {&#10;        rollDiceButton.setEnabled(false);&#10;&#10;        // Use DiceController for dice animation and logic&#10;        diceAnimator.startDiceAnimation(&#10;            this::repaint, // Animation frame callback&#10;            this::onDiceRollComplete // Completion callback&#10;        );&#10;    }&#10;&#10;    /**&#10;     * Handle dice roll completion - delegate movement to game logic&#10;     */&#10;    private void onDiceRollComplete() {&#10;        Player currentPlayer = game.getCurrentPlayer();&#10;        int diceSum = diceAnimator.getLastDiceSum();&#10;&#10;        // Handle crossing GO bonus using GameBoard logic&#10;        gameMoveCurrentPlayer.execute(diceSum);&#10;&#10;        // Use PlayerMovementAnimator for movement animation&#10;        playerMovementAnimator.animatePlayerMovement(&#10;            currentPlayer,&#10;            diceSum,&#10;            game.getTileCount(),&#10;            this::repaint, // Movement step callback&#10;            this::onPlayerMovementComplete // Completion callback&#10;        );&#10;    }&#10;&#10;    /**&#10;     * Handle player movement completion - delegate to tile logic&#10;     */&#10;    private void onPlayerMovementComplete() {&#10;        handleLandingOnTile();&#10;    }&#10;&#10;    /**&#10;     * Handle landing on tile - delegate to tile's onLanding method&#10;     * The tile will use the appropriate controller (PropertyController for properties)&#10;     */&#10;    private void handleLandingOnTile() {&#10;        Player currentPlayer = game.getCurrentPlayer();&#10;        int position = currentPlayer.getPosition();&#10;        Tile tile = game.getPropertyAt(position);&#10;&#10;        if (tile != null) {&#10;            // Use tile's built-in landing logic which will call the appropriate controller&#10;            tile.onLanding(currentPlayer);&#10;&#10;            // Check if presenter has any view models to display&#10;            checkForPresenterUpdates();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Check if the presenter has any view models ready and display them&#10;     */&#10;    private void checkForPresenterUpdates() {&#10;        // Check for purchase dialog&#10;        PurchaseDialogViewModel purchaseDialog = propertyPresenter.getPurchaseDialogViewModel();&#10;        if (purchaseDialog != null) {&#10;            PropertyPurchaseUseCase.PurchaseResultCallback callback = propertyPresenter.getPurchaseCallback();&#10;            showPurchaseDialog(purchaseDialog, callback);&#10;            propertyPresenter.clearPurchaseDialog();&#10;        }&#10;&#10;        // Check for property purchased notification&#10;        PropertyPurchasedViewModel propertyPurchased = propertyPresenter.getPropertyPurchasedViewModel();&#10;        if (propertyPurchased != null) {&#10;            updateAfterPropertyPurchased(propertyPurchased);&#10;            propertyPresenter.clearPropertyPurchased();&#10;        }&#10;&#10;        // Check for rent payment notification&#10;        RentPaymentViewModel rentPayment = propertyPresenter.getRentPaymentViewModel();&#10;        if (rentPayment != null) {&#10;            showRentPaymentNotification(rentPayment);&#10;            propertyPresenter.clearRentPayment();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle end turn - delegate to game logic&#10;     */&#10;    private void handleEndTurn() {&#10;        new GameNextTurn(game).execute();&#10;        updateStatusLabels();&#10;        statsPanel.updatePlayers(game.getPlayers());&#10;&#10;        if (game.isGameOver()) {&#10;            showEndScreen();&#10;            return;&#10;        }&#10;&#10;        rollDiceButton.setEnabled(true);&#10;        repaint();&#10;    }&#10;&#10;    /**&#10;     * Show end screen when game is over&#10;     */&#10;    private void showEndScreen() {&#10;        rollDiceButton.setEnabled(false);&#10;        endTurnButton.setEnabled(false);&#10;&#10;        // Hide the parent frame if it exists&#10;        if (parentFrame != null) {&#10;            parentFrame.setVisible(false);&#10;        }&#10;&#10;        // Show the end screen&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            new EndScreen(&#10;                    game.getPlayers(),&#10;                    game.getGameEndReason(),&#10;                    game.getCurrentRound()&#10;            );&#10;        });&#10;    }&#10;&#10;    public int getLastDiceSum() {&#10;        return diceAnimator.getLastDiceSum();&#10;    }&#10;&#10;    /**&#10;     * For Testing the Board View on its own&#10;     */&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            JFrame frame = new JFrame(&quot;Monopoly Board&quot;);&#10;            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;            BoardView boardView = new BoardView();&#10;            boardView.setParentFrame(frame);&#10;            frame.add(boardView);&#10;            frame.pack();&#10;            frame.setLocationRelativeTo(null);&#10;            frame.setVisible(true);&#10;        });&#10;    }&#10;&#10;    // Property-related view methods (now work with view models only)&#10;    public void showPurchaseDialog(PurchaseDialogViewModel viewModel, PropertyPurchaseUseCase.PurchaseResultCallback callback) {&#10;        Frame parentFrame = (Frame) SwingUtilities.getWindowAncestor(this);&#10;&#10;        // Find the actual player and property objects for the popup&#10;        Player player = findPlayerByName(viewModel.playerName);&#10;        PropertyTile property = findPropertyByName(viewModel.propertyName);&#10;&#10;        if (player != null &amp;&amp; property != null) {&#10;            BuyPropertyPopup.showPurchaseDialog(parentFrame, player, property,&#10;                    (success, message) -&gt; callback.onResult(success));&#10;        }&#10;    }&#10;&#10;    public void updateAfterPropertyPurchased(PropertyPurchasedViewModel viewModel) {&#10;        // Update UI after property purchase&#10;        statsPanel.updatePlayers(game.getPlayers());&#10;        repaint(); // Trigger board repaint to show ownership change&#10;    }&#10;&#10;    public void showRentPaymentNotification(RentPaymentViewModel viewModel) {&#10;        // Show rent payment notification&#10;        Frame parentFrame = (Frame) SwingUtilities.getWindowAncestor(this);&#10;        showRentNotification(parentFrame, viewModel);&#10;&#10;        // Update UI after rent payment&#10;        statsPanel.updatePlayers(game.getPlayers());&#10;        repaint();&#10;    }&#10;&#10;    // Helper methods for finding entities (needed for legacy popup interface)&#10;    private Player findPlayerByName(String name) {&#10;        return game.getPlayers().stream()&#10;                .filter(p -&gt; p.getName().equals(name))&#10;                .findFirst()&#10;                .orElse(null);&#10;    }&#10;&#10;    private PropertyTile findPropertyByName(String name) {&#10;        return game.getTiles().stream()&#10;                .filter(tile -&gt; tile.getName().equals(name))&#10;                .findFirst()&#10;                .orElse(null);&#10;    }&#10;&#10;    /**&#10;     * Shows rent payment notification dialog using view model data&#10;     */&#10;    private void showRentNotification(Frame parent, RentPaymentViewModel viewModel) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            String message = viewModel.payerName + &quot; paid $&quot; + (int) viewModel.rentAmount +&#10;                    &quot; rent to &quot; + viewModel.ownerName + &quot; for landing on &quot; + viewModel.propertyName;&#10;&#10;            JOptionPane.showMessageDialog(&#10;                    parent,&#10;                    message,&#10;                    &quot;Rent Payment&quot;,&#10;                    JOptionPane.INFORMATION_MESSAGE&#10;            );&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/view/GenericTileView.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/view/GenericTileView.java" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/view/GoTileView.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/view/GoTileView.java" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/view/PropertyTileView.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/view/PropertyTileView.java" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/view/TileView.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/view/TileView.java" />
              <option name="originalContent" value="package main.view;&#10;&#10;import main.entity.tiles.PropertyTile;&#10;import main.entity.tiles.StockMarketTile;&#10;import main.use_case.Tile;&#10;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;&#10;/**&#10; * Generic visual component for a single board tile.&#10; * Provides basic text display functionality that can be configured by presenters.&#10; */&#10;public class TileView extends JPanel {&#10;    private final JLabel mainLabel;&#10;    private final JLabel priceLabel;&#10;    private final JLabel ownerLabel;&#10;&#10;    /**&#10;     * Create a generic tile view with basic layout&#10;     */&#10;    public TileView() {&#10;        this.setLayout(new BorderLayout());&#10;        this.setBorder(BorderFactory.createLineBorder(Color.BLACK));&#10;        this.setBackground(Color.LIGHT_GRAY);&#10;&#10;        mainLabel = new JLabel(&quot;&quot;, SwingConstants.CENTER);&#10;        mainLabel.setFont(mainLabel.getFont().deriveFont(10f));&#10;        this.add(mainLabel, BorderLayout.NORTH);&#10;&#10;        priceLabel = new JLabel(&quot;&quot;, SwingConstants.CENTER);&#10;        priceLabel.setFont(priceLabel.getFont().deriveFont(9f));&#10;        this.add(priceLabel, BorderLayout.CENTER);&#10;&#10;        ownerLabel = new JLabel(&quot;&quot;, SwingConstants.CENTER);&#10;        ownerLabel.setFont(ownerLabel.getFont().deriveFont(8f));&#10;        this.add(ownerLabel, BorderLayout.SOUTH);&#10;    }&#10;&#10;    /**&#10;     * Set the main text (tile name)&#10;     */&#10;    public void setMainText(String text) {&#10;        mainLabel.setText(text != null ? text : &quot;&quot;);&#10;        repaint();&#10;    }&#10;&#10;    /**&#10;     * Set the price text&#10;     */&#10;    public void setPriceText(String text) {&#10;        priceLabel.setText(text != null ? text : &quot;&quot;);&#10;        repaint();&#10;    }&#10;&#10;    /**&#10;     * Set the owner text&#10;     */&#10;    public void setOwnerText(String text) {&#10;        ownerLabel.setText(text != null ? text : &quot;&quot;);&#10;        repaint();&#10;    }&#10;&#10;    /**&#10;     * Hide price and owner labels (for non-property tiles)&#10;     */&#10;    public void hidePropertyInfo() {&#10;        priceLabel.setVisible(false);&#10;        ownerLabel.setVisible(false);&#10;        repaint();&#10;    }&#10;&#10;    /**&#10;     * Show price and owner labels (for property tiles)&#10;     */&#10;    public void showPropertyInfo() {&#10;        priceLabel.setVisible(true);&#10;        ownerLabel.setVisible(true);&#10;        repaint();&#10;    }&#10;&#10;    /**&#10;     * TODO: Configure this TileView based on the tile type.&#10;     * This method handles the general tile configuration logic.&#10;     */&#10;    public void configureForTile(Tile tile) {&#10;        if (tile instanceof PropertyTile) {&#10;            PropertyTile property = (PropertyTile) tile;&#10;            setMainText(tile.getName());&#10;            setPriceText(&quot;$&quot; + (int)property.getPrice());&#10;            showPropertyInfo();&#10;&#10;            if (property.isOwned()) {&#10;                setOwnerText(property.getOwner().getName());&#10;            } else {&#10;                setOwnerText(&quot;&quot;);&#10;            }&#10;        } else if (tile instanceof StockMarketTile) {&#10;            setMainText(&quot;Stock Market&quot;);&#10;            hidePropertyInfo();&#10;        } else {&#10;            setMainText(tile.getName());&#10;            hidePropertyInfo();&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        JFrame frame = new JFrame(&quot;Tile View Example&quot;);&#10;        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        frame.setSize(200, 200);&#10;&#10;        TileView tileView = new TileView();&#10;        tileView.setMainText(&quot;Cool Name&quot;);&#10;        tileView.setPriceText(&quot;$350&quot;);&#10;        tileView.setOwnerText(&quot;Player 1&quot;);&#10;&#10;        frame.add(tileView);&#10;        frame.setVisible(true);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package main.view;&#10;&#10;import main.entity.tiles.PropertyTile;&#10;import main.entity.tiles.StockMarketTile;&#10;import main.use_case.Tile;&#10;import main.interface_adapter.Property.PropertyViewModel.*;&#10;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;&#10;/**&#10; * Generic visual component for a single board tile.&#10; * Provides basic text display functionality that can be configured by presenters.&#10; */&#10;public class TileView extends JPanel {&#10;    private final JLabel mainLabel;&#10;    private final JLabel priceLabel;&#10;    private final JLabel ownerLabel;&#10;&#10;    /**&#10;     * Create a generic tile view with basic layout&#10;     */&#10;    public TileView() {&#10;        this.setLayout(new BorderLayout());&#10;        this.setBorder(BorderFactory.createLineBorder(Color.BLACK));&#10;        this.setBackground(Color.LIGHT_GRAY);&#10;&#10;        mainLabel = new JLabel(&quot;&quot;, SwingConstants.CENTER);&#10;        mainLabel.setFont(mainLabel.getFont().deriveFont(10f));&#10;        this.add(mainLabel, BorderLayout.NORTH);&#10;&#10;        priceLabel = new JLabel(&quot;&quot;, SwingConstants.CENTER);&#10;        priceLabel.setFont(priceLabel.getFont().deriveFont(9f));&#10;        this.add(priceLabel, BorderLayout.CENTER);&#10;&#10;        ownerLabel = new JLabel(&quot;&quot;, SwingConstants.CENTER);&#10;        ownerLabel.setFont(ownerLabel.getFont().deriveFont(8f));&#10;        this.add(ownerLabel, BorderLayout.SOUTH);&#10;    }&#10;&#10;    /**&#10;     * Set the main text (tile name)&#10;     */&#10;    public void setMainText(String text) {&#10;        mainLabel.setText(text != null ? text : &quot;&quot;);&#10;        repaint();&#10;    }&#10;&#10;    /**&#10;     * Set the price text&#10;     */&#10;    public void setPriceText(String text) {&#10;        priceLabel.setText(text != null ? text : &quot;&quot;);&#10;        repaint();&#10;    }&#10;&#10;    /**&#10;     * Set the owner text&#10;     */&#10;    public void setOwnerText(String text) {&#10;        ownerLabel.setText(text != null ? text : &quot;&quot;);&#10;        repaint();&#10;    }&#10;&#10;    /**&#10;     * Hide price and owner labels (for non-property tiles)&#10;     */&#10;    public void hidePropertyInfo() {&#10;        priceLabel.setVisible(false);&#10;        ownerLabel.setVisible(false);&#10;        repaint();&#10;    }&#10;&#10;    /**&#10;     * Show price and owner labels (for property tiles)&#10;     */&#10;    public void showPropertyInfo() {&#10;        priceLabel.setVisible(true);&#10;        ownerLabel.setVisible(true);&#10;        repaint();&#10;    }&#10;&#10;    /**&#10;     * TODO: Configure this TileView based on the tile type.&#10;     * This method handles the general tile configuration logic.&#10;     */&#10;    public void configureForTile(Tile tile) {&#10;        if (tile instanceof PropertyTile) {&#10;            PropertyTile property = (PropertyTile) tile;&#10;            setMainText(tile.getName());&#10;            setPriceText(&quot;$&quot; + (int)property.getPrice());&#10;            showPropertyInfo();&#10;&#10;            if (property.isOwned()) {&#10;                setOwnerText(property.getOwner().getName());&#10;            } else {&#10;                setOwnerText(&quot;&quot;);&#10;            }&#10;        } else if (tile instanceof StockMarketTile) {&#10;            setMainText(&quot;Stock Market&quot;);&#10;            hidePropertyInfo();&#10;        } else {&#10;            setMainText(tile.getName());&#10;            hidePropertyInfo();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update this tile view using a property purchased view model.&#10;     * This allows the presenter to update individual tiles without depending on the view.&#10;     */&#10;    public void updateFromPropertyPurchased(PropertyPurchasedViewModel viewModel, Tile tile) {&#10;        if (tile instanceof PropertyTile) {&#10;            PropertyTile property = (PropertyTile) tile;&#10;            if (property.getName().equals(viewModel.propertyName)) {&#10;                setOwnerText(viewModel.ownerName);&#10;                // Optionally change background color to indicate ownership&#10;                setBackground(Color.YELLOW);&#10;                repaint();&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update this tile view to reflect rent payment (visual feedback)&#10;     */&#10;    public void updateFromRentPayment(RentPaymentViewModel viewModel, Tile tile) {&#10;        if (tile instanceof PropertyTile) {&#10;            PropertyTile property = (PropertyTile) tile;&#10;            if (property.getName().equals(viewModel.propertyName)) {&#10;                // Temporarily highlight the tile to show rent was paid&#10;                setBackground(Color.RED);&#10;                repaint();&#10;                &#10;                // Reset color after a brief delay&#10;                Timer timer = new Timer(1000, e -&gt; {&#10;                    setBackground(Color.LIGHT_GRAY);&#10;                    repaint();&#10;                });&#10;                timer.setRepeats(false);&#10;                timer.start();&#10;            }&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        JFrame frame = new JFrame(&quot;Tile View Example&quot;);&#10;        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        frame.setSize(200, 200);&#10;&#10;        TileView tileView = new TileView();&#10;        tileView.setMainText(&quot;Cool Name&quot;);&#10;        tileView.setPriceText(&quot;$350&quot;);&#10;        tileView.setOwnerText(&quot;Player 1&quot;);&#10;&#10;        frame.add(tileView);&#10;        frame.setVisible(true);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>