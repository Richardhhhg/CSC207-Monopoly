<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/entity/tiles/PropertyTile.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/entity/tiles/PropertyTile.java" />
              <option name="originalContent" value="package main.entity.tiles;&#10;&#10;import main.entity.players.rentModifier;&#10;import main.use_case.Tile;&#10;import main.entity.players.Player;&#10;&#10;/*&#10; * A purchasable board tile that can collect rent.&#10; * */&#10;public class PropertyTile extends Tile {&#10;    private final float price;&#10;    private final float rent;&#10;    private Player owner; //null if not owned&#10;&#10;    // Interface for handling property landing events&#10;    public interface PropertyLandingHandler {&#10;        void handleUnownedProperty(Player player, PropertyTile property);&#10;        void handleRentPayment(Player payer, Player owner, PropertyTile property, float rentAmount);&#10;    }&#10;&#10;    private PropertyLandingHandler landingHandler;&#10;&#10;    /**&#10;     * @param name  tile name&#10;     * @param price purchase price&#10;     * @param rent  base rent amount&#10;     */&#10;    public PropertyTile(String name, float price, float rent) {&#10;        super(name);&#10;        this.price = price;&#10;        this.rent = rent;&#10;    }&#10;&#10;    public void setLandingHandler(PropertyLandingHandler handler) {&#10;        this.landingHandler = handler;&#10;    }&#10;&#10;    /**&#10;     * @return purchase price&#10;     */&#10;    public float getPrice() {&#10;        return price;&#10;    }&#10;&#10;    /**&#10;     * @return base rent (before adjustment)&#10;     */&#10;    public float getRent() {&#10;        return rent;&#10;    }&#10;&#10;    /**&#10;     * @return true if someone owns this property&#10;     */&#10;    public boolean isOwned() {&#10;        return owner != null;&#10;    }&#10;&#10;    /**&#10;     * @return the owning player, or null if unowned&#10;     */&#10;    public Player getOwner() {&#10;        return owner;&#10;    }&#10;&#10;    /**&#10;     * When a player lands here - delegate to handler for UI concerns&#10;     */&#10;    @Override&#10;    public void onLanding(Player p) {&#10;        if (!isOwned()) {&#10;            if (landingHandler != null) {&#10;                landingHandler.handleUnownedProperty(p, this);&#10;            }&#10;            return;&#10;        }&#10;&#10;        if (p != owner) {&#10;            // Calculate rent&#10;            float finalRent = rent;&#10;            if (owner instanceof rentModifier) {&#10;                finalRent = ((rentModifier) owner).adjustRent(rent);&#10;            }&#10;&#10;            // Perform the transaction&#10;            p.deductMoney(finalRent);&#10;            owner.addMoney(finalRent);&#10;&#10;            // Notify handler about rent payment&#10;            if (landingHandler != null) {&#10;                landingHandler.handleRentPayment(p, owner, this, finalRent);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Business logic for purchasing this property&#10;     */&#10;    public boolean attemptPurchase(Player player) {&#10;        if (isOwned() || player.getMoney() &lt; price) {&#10;            return false;&#10;        }&#10;&#10;        player.buyProperty(this);&#10;        this.owner = player;&#10;        return true;&#10;    }&#10;&#10;    /**&#10;     * Sets or clears ownership.&#10;     *&#10;     * @param owned ignored; ownership is determined by non-null owner&#10;     * @param owner the new owner, or null to clear&#10;     */&#10;    public void setOwned(boolean owned, Player owner) {&#10;        this.owner = owner;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package main.entity.tiles;&#10;&#10;import main.entity.players.rentModifier;&#10;import main.use_case.Tile;&#10;import main.entity.players.Player;&#10;import main.interface_adapter.Property.PropertyLandingHandler;&#10;&#10;/*&#10; * A purchasable board tile that can collect rent.&#10; * */&#10;public class PropertyTile extends Tile {&#10;    private final float price;&#10;    private final float rent;&#10;    private Player owner; //null if not owned&#10;&#10;    private PropertyLandingHandler landingHandler;&#10;&#10;    /**&#10;     * @param name  tile name&#10;     * @param price purchase price&#10;     * @param rent  base rent amount&#10;     */&#10;    public PropertyTile(String name, float price, float rent) {&#10;        super(name);&#10;        this.price = price;&#10;        this.rent = rent;&#10;    }&#10;&#10;    public void setLandingHandler(PropertyLandingHandler handler) {&#10;        this.landingHandler = handler;&#10;    }&#10;&#10;    /**&#10;     * @return purchase price&#10;     */&#10;    public float getPrice() {&#10;        return price;&#10;    }&#10;&#10;    /**&#10;     * @return base rent (before adjustment)&#10;     */&#10;    public float getRent() {&#10;        return rent;&#10;    }&#10;&#10;    /**&#10;     * @return true if someone owns this property&#10;     */&#10;    public boolean isOwned() {&#10;        return owner != null;&#10;    }&#10;&#10;    /**&#10;     * @return the owning player, or null if unowned&#10;     */&#10;    public Player getOwner() {&#10;        return owner;&#10;    }&#10;&#10;    /**&#10;     * When a player lands here - delegate to handler for UI concerns&#10;     */&#10;    @Override&#10;    public void onLanding(Player p) {&#10;        if (!isOwned()) {&#10;            if (landingHandler != null) {&#10;                landingHandler.handleUnownedProperty(p, this);&#10;            }&#10;            return;&#10;        }&#10;&#10;        if (p != owner) {&#10;            // Calculate rent&#10;            float finalRent = rent;&#10;            if (owner instanceof rentModifier) {&#10;                finalRent = ((rentModifier) owner).adjustRent(rent);&#10;            }&#10;&#10;            // Perform the transaction&#10;            p.deductMoney(finalRent);&#10;            owner.addMoney(finalRent);&#10;&#10;            // Notify handler about rent payment&#10;            if (landingHandler != null) {&#10;                landingHandler.handleRentPayment(p, owner, this, finalRent);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Business logic for purchasing this property&#10;     */&#10;    public boolean attemptPurchase(Player player) {&#10;        if (isOwned() || player.getMoney() &lt; price) {&#10;            return false;&#10;        }&#10;&#10;        player.buyProperty(this);&#10;        this.owner = player;&#10;        return true;&#10;    }&#10;&#10;    /**&#10;     * Sets or clears ownership.&#10;     *&#10;     * @param owned ignored; ownership is determined by non-null owner&#10;     * @param owner the new owner, or null to clear&#10;     */&#10;    public void setOwned(boolean owned, Player owner) {&#10;        this.owner = owner;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/interface_adapter/Property/PropertyController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/interface_adapter/Property/PropertyController.java" />
              <option name="originalContent" value="package main.interface_adapter.Property;&#10;&#10;import main.entity.tiles.PropertyTile;&#10;import main.entity.players.Player;&#10;&#10;/**&#10; * Controller that handles property-related business logic and coordinates&#10; * between the model (PropertyTile) and presenter (PropertyPresenter)&#10; */&#10;public class PropertyController implements PropertyLandingHandler {&#10;    private final PropertyPresenter presenter;&#10;&#10;    public PropertyController(PropertyPresenter presenter) {&#10;        this.presenter = presenter;&#10;    }&#10;&#10;    @Override&#10;    public void handleUnownedProperty(Player player, PropertyTile property) {&#10;        // Business logic: Check if property can be purchased&#10;        if (property.isOwned()) {&#10;            return; // Should not happen, but safety check&#10;        }&#10;&#10;        // Delegate to presenter for UI handling&#10;        presenter.showPurchaseDialog(player, property, (success, message) -&gt; {&#10;            if (success) {&#10;                // Notify presenter to update UI&#10;                presenter.onPropertyPurchased(player, property);&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void handleRentPayment(Player payer, Player owner, PropertyTile property, float rentAmount) {&#10;        // Business logic is already handled in PropertyTile.onLanding()&#10;        // Just notify presenter to show the result&#10;        presenter.showRentPayment(payer, owner, property, rentAmount);&#10;        presenter.onRentPaid(payer, owner, rentAmount);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package main.interface_adapter.Property;&#10;&#10;import main.entity.tiles.PropertyTile;&#10;import main.entity.players.Player;&#10;import main.use_case.Property.PropertyLandingUseCase;&#10;&#10;/**&#10; * Controller that handles property-related input and delegates to use cases.&#10; * Controllers should only coordinate between input and use cases, not presenters.&#10; */&#10;public class PropertyController implements PropertyLandingHandler {&#10;    private final PropertyLandingUseCase propertyLandingUseCase;&#10;&#10;    public PropertyController(PropertyLandingUseCase propertyLandingUseCase) {&#10;        this.propertyLandingUseCase = propertyLandingUseCase;&#10;    }&#10;&#10;    @Override&#10;    public void handleUnownedProperty(Player player, PropertyTile property) {&#10;        // Delegate to use case - controller doesn't handle business logic&#10;        propertyLandingUseCase.handleUnownedProperty(player, property);&#10;    }&#10;&#10;    @Override&#10;    public void handleRentPayment(Player payer, Player owner, PropertyTile property, float rentAmount) {&#10;        // Delegate to use case - controller doesn't handle business logic&#10;        propertyLandingUseCase.handleRentPayment(payer, owner, property, rentAmount);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/interface_adapter/Property/PropertyLandingHandler.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/interface_adapter/Property/PropertyLandingHandler.java" />
              <option name="updatedContent" value="package main.interface_adapter.Property;&#10;&#10;import main.entity.tiles.PropertyTile;&#10;import main.entity.players.Player;&#10;&#10;/**&#10; * Interface for handling property landing events.&#10; * This follows the dependency inversion principle by allowing PropertyTile&#10; * to depend on an abstraction rather than concrete implementations.&#10; */&#10;public interface PropertyLandingHandler {&#10;    void handleUnownedProperty(Player player, PropertyTile property);&#10;    void handleRentPayment(Player payer, Player owner, PropertyTile property, float rentAmount);&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/interface_adapter/Property/PropertyPresenter.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/interface_adapter/Property/PropertyPresenter.java" />
              <option name="originalContent" value="package main.interface_adapter.Property;&#10;&#10;import main.use_case.Property.PropertyLandingOutputBoundary;&#10;import main.use_case.Property.PropertyLandingUseCase.*;&#10;import main.interface_adapter.Property.PropertyViewModel.*;&#10;&#10;/**&#10; * Presenter that implements the output boundary and creates view models for property-related UI.&#10; * No longer depends on concrete view classes - uses interface and view models instead.&#10; */&#10;public class PropertyPresenter implements PropertyLandingOutputBoundary {&#10;    private final PropertyViewInterface view;&#10;&#10;    public PropertyPresenter(PropertyViewInterface view) {&#10;        this.view = view;&#10;    }&#10;&#10;    @Override&#10;    public void presentPurchaseDialog(PropertyPurchaseData data, PurchaseResultCallback callback) {&#10;        // Convert use case data to view model&#10;        PurchaseDialogViewModel viewModel = new PurchaseDialogViewModel(&#10;            data.playerName,&#10;            data.playerMoney,&#10;            data.propertyName,&#10;            data.propertyPrice,&#10;            data.canAfford&#10;        );&#10;&#10;        // Send view model to view&#10;        view.showPurchaseDialog(viewModel, callback);&#10;    }&#10;&#10;    @Override&#10;    public void presentPropertyPurchased(PropertyOwnershipData data) {&#10;        // Convert use case data to view model&#10;        PropertyPurchasedViewModel viewModel = new PropertyPurchasedViewModel(&#10;            data.propertyName,&#10;            data.ownerName,&#10;            data.newOwnerMoney&#10;        );&#10;&#10;        // Send view model to view&#10;        view.updateAfterPropertyPurchased(viewModel);&#10;    }&#10;&#10;    @Override&#10;    public void presentRentPayment(RentPaymentData data) {&#10;        // Convert use case data to view model&#10;        RentPaymentViewModel viewModel = new RentPaymentViewModel(&#10;            data.payerName,&#10;            data.ownerName,&#10;            data.propertyName,&#10;            data.rentAmount,&#10;            data.payerNewMoney,&#10;            data.ownerNewMoney&#10;        );&#10;&#10;        // Send view model to view&#10;        view.showRentPaymentNotification(viewModel);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package main.interface_adapter.Property;&#10;&#10;import main.use_case.Property.PropertyLandingOutputBoundary;&#10;import main.use_case.Property.PropertyLandingUseCase.*;&#10;import main.interface_adapter.Property.PropertyViewModel.*;&#10;import main.view.BoardView;&#10;&#10;/**&#10; * Presenter that implements the output boundary and creates view models for property-related UI.&#10; * Directly communicates with BoardView without unnecessary interface abstraction.&#10; */&#10;public class PropertyPresenter implements PropertyLandingOutputBoundary {&#10;    private final BoardView boardView;&#10;&#10;    public PropertyPresenter(BoardView boardView) {&#10;        this.boardView = boardView;&#10;    }&#10;&#10;    @Override&#10;    public void presentPurchaseDialog(PropertyPurchaseData data, PurchaseResultCallback callback) {&#10;        // Convert use case data to view model&#10;        PurchaseDialogViewModel viewModel = new PurchaseDialogViewModel(&#10;            data.playerName,&#10;            data.playerMoney,&#10;            data.propertyName,&#10;            data.propertyPrice,&#10;            data.canAfford&#10;        );&#10;        &#10;        // Send view model to board view&#10;        boardView.showPurchaseDialog(viewModel, callback);&#10;    }&#10;&#10;    @Override&#10;    public void presentPropertyPurchased(PropertyOwnershipData data) {&#10;        // Convert use case data to view model&#10;        PropertyPurchasedViewModel viewModel = new PropertyPurchasedViewModel(&#10;            data.propertyName,&#10;            data.ownerName,&#10;            data.newOwnerMoney&#10;        );&#10;        &#10;        // Send view model to board view&#10;        boardView.updateAfterPropertyPurchased(viewModel);&#10;    }&#10;&#10;    @Override&#10;    public void presentRentPayment(RentPaymentData data) {&#10;        // Convert use case data to view model&#10;        RentPaymentViewModel viewModel = new RentPaymentViewModel(&#10;            data.payerName,&#10;            data.ownerName,&#10;            data.propertyName,&#10;            data.rentAmount,&#10;            data.payerNewMoney,&#10;            data.ownerNewMoney&#10;        );&#10;        &#10;        // Send view model to board view&#10;        boardView.showRentPaymentNotification(viewModel);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/interface_adapter/Property/PropertyViewInterface.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/interface_adapter/Property/PropertyViewInterface.java" />
              <option name="updatedContent" value="package main.interface_adapter.Property;&#10;&#10;import main.interface_adapter.Property.PropertyViewModel.*;&#10;import main.use_case.Property.PropertyLandingUseCase.PurchaseResultCallback;&#10;&#10;/**&#10; * Interface for property-related view operations.&#10; * Views implement this to receive view models from the presenter.&#10; */&#10;public interface PropertyViewInterface {&#10;    void showPurchaseDialog(PurchaseDialogViewModel viewModel, PurchaseResultCallback callback);&#10;    void updateAfterPropertyPurchased(PropertyPurchasedViewModel viewModel);&#10;    void showRentPaymentNotification(RentPaymentViewModel viewModel);&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/interface_adapter/Property/PropertyViewModel.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/interface_adapter/Property/PropertyViewModel.java" />
              <option name="updatedContent" value="package main.interface_adapter.Property;&#10;&#10;/**&#10; * View models for property-related UI data.&#10; * These are data containers that the presenter creates and the view consumes.&#10; */&#10;public class PropertyViewModel {&#10;    &#10;    public static class PurchaseDialogViewModel {&#10;        public final String playerName;&#10;        public final float playerMoney;&#10;        public final String propertyName;&#10;        public final float propertyPrice;&#10;        public final boolean canAfford;&#10;        &#10;        public PurchaseDialogViewModel(String playerName, float playerMoney, String propertyName,&#10;                                     float propertyPrice, boolean canAfford) {&#10;            this.playerName = playerName;&#10;            this.playerMoney = playerMoney;&#10;            this.propertyName = propertyName;&#10;            this.propertyPrice = propertyPrice;&#10;            this.canAfford = canAfford;&#10;        }&#10;    }&#10;    &#10;    public static class PropertyPurchasedViewModel {&#10;        public final String propertyName;&#10;        public final String ownerName;&#10;        public final float newOwnerMoney;&#10;        &#10;        public PropertyPurchasedViewModel(String propertyName, String ownerName, float newOwnerMoney) {&#10;            this.propertyName = propertyName;&#10;            this.ownerName = ownerName;&#10;            this.newOwnerMoney = newOwnerMoney;&#10;        }&#10;    }&#10;    &#10;    public static class RentPaymentViewModel {&#10;        public final String payerName;&#10;        public final String ownerName;&#10;        public final String propertyName;&#10;        public final float rentAmount;&#10;        public final float payerNewMoney;&#10;        public final float ownerNewMoney;&#10;        &#10;        public RentPaymentViewModel(String payerName, String ownerName, String propertyName,&#10;                                  float rentAmount, float payerNewMoney, float ownerNewMoney) {&#10;            this.payerName = payerName;&#10;            this.ownerName = ownerName;&#10;            this.propertyName = propertyName;&#10;            this.rentAmount = rentAmount;&#10;            this.payerNewMoney = payerNewMoney;&#10;            this.ownerNewMoney = ownerNewMoney;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/use_case/Property/PropertyLandingOutputBoundary.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/use_case/Property/PropertyLandingOutputBoundary.java" />
              <option name="updatedContent" value="package main.use_case.Property;&#10;&#10;import main.use_case.Property.PropertyLandingUseCase.*;&#10;&#10;/**&#10; * Output boundary interface for property landing use case.&#10; * Presenters implement this to receive data from the use case.&#10; */&#10;public interface PropertyLandingOutputBoundary {&#10;    void presentPurchaseDialog(PropertyPurchaseData data, PurchaseResultCallback callback);&#10;    void presentPropertyPurchased(PropertyOwnershipData data);&#10;    void presentRentPayment(RentPaymentData data);&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/use_case/Property/PropertyLandingUseCase.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/use_case/Property/PropertyLandingUseCase.java" />
              <option name="updatedContent" value="package main.use_case.Property;&#10;&#10;import main.entity.tiles.PropertyTile;&#10;import main.entity.players.Player;&#10;&#10;/**&#10; * Use case for handling property landing events.&#10; * This contains the business logic and coordinates with the presenter through an interface.&#10; */&#10;public class PropertyLandingUseCase {&#10;    private final PropertyLandingOutputBoundary presenter;&#10;&#10;    public PropertyLandingUseCase(PropertyLandingOutputBoundary presenter) {&#10;        this.presenter = presenter;&#10;    }&#10;&#10;    public void handleUnownedProperty(Player player, PropertyTile property) {&#10;        // Business logic: Validate property can be purchased&#10;        if (property.isOwned()) {&#10;            return; // Should not happen, but safety check&#10;        }&#10;&#10;        // Create data transfer object for presenter&#10;        PropertyPurchaseData purchaseData = new PropertyPurchaseData(&#10;            player.getName(),&#10;            player.getMoney(),&#10;            property.getName(),&#10;            property.getPrice(),&#10;            player.getMoney() &gt;= property.getPrice()&#10;        );&#10;&#10;        // Send to presenter through output boundary&#10;        presenter.presentPurchaseDialog(purchaseData, (success) -&gt; {&#10;            if (success) {&#10;                // Execute the purchase&#10;                boolean purchaseSuccessful = property.attemptPurchase(player);&#10;                if (purchaseSuccessful) {&#10;                    PropertyOwnershipData ownershipData = new PropertyOwnershipData(&#10;                        property.getName(),&#10;                        player.getName(),&#10;                        player.getMoney()&#10;                    );&#10;                    presenter.presentPropertyPurchased(ownershipData);&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    public void handleRentPayment(Player payer, Player owner, PropertyTile property, float rentAmount) {&#10;        // Business logic is already handled in PropertyTile.onLanding()&#10;        // Create data transfer object for presenter&#10;        RentPaymentData rentData = new RentPaymentData(&#10;            payer.getName(),&#10;            owner.getName(),&#10;            property.getName(),&#10;            rentAmount,&#10;            payer.getMoney(),&#10;            owner.getMoney()&#10;        );&#10;&#10;        // Send to presenter through output boundary&#10;        presenter.presentRentPayment(rentData);&#10;    }&#10;&#10;    // Data transfer objects for presenter communication&#10;    public static class PropertyPurchaseData {&#10;        public final String playerName;&#10;        public final float playerMoney;&#10;        public final String propertyName;&#10;        public final float propertyPrice;&#10;        public final boolean canAfford;&#10;&#10;        public PropertyPurchaseData(String playerName, float playerMoney, String propertyName, &#10;                                  float propertyPrice, boolean canAfford) {&#10;            this.playerName = playerName;&#10;            this.playerMoney = playerMoney;&#10;            this.propertyName = propertyName;&#10;            this.propertyPrice = propertyPrice;&#10;            this.canAfford = canAfford;&#10;        }&#10;    }&#10;&#10;    public static class PropertyOwnershipData {&#10;        public final String propertyName;&#10;        public final String ownerName;&#10;        public final float newOwnerMoney;&#10;&#10;        public PropertyOwnershipData(String propertyName, String ownerName, float newOwnerMoney) {&#10;            this.propertyName = propertyName;&#10;            this.ownerName = ownerName;&#10;            this.newOwnerMoney = newOwnerMoney;&#10;        }&#10;    }&#10;&#10;    public static class RentPaymentData {&#10;        public final String payerName;&#10;        public final String ownerName;&#10;        public final String propertyName;&#10;        public final float rentAmount;&#10;        public final float payerNewMoney;&#10;        public final float ownerNewMoney;&#10;&#10;        public RentPaymentData(String payerName, String ownerName, String propertyName,&#10;                             float rentAmount, float payerNewMoney, float ownerNewMoney) {&#10;            this.payerName = payerName;&#10;            this.ownerName = ownerName;&#10;            this.propertyName = propertyName;&#10;            this.rentAmount = rentAmount;&#10;            this.payerNewMoney = payerNewMoney;&#10;            this.ownerNewMoney = ownerNewMoney;&#10;        }&#10;    }&#10;&#10;    public interface PurchaseResultCallback {&#10;        void onResult(boolean success);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/view/BoardView.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/view/BoardView.java" />
              <option name="originalContent" value="package main.view;&#10;&#10;import main.entity.tiles.PropertyTile;&#10;import main.entity.players.Player;&#10;import main.entity.*;&#10;import main.use_case.Game.GameNextTurn;&#10;import main.Constants.Constants;&#10;import main.use_case.Tile;&#10;import main.interface_adapter.Property.PropertyController;&#10;import main.interface_adapter.Property.PropertyPresenter;&#10;import main.interface_adapter.Property.PropertyViewInterface;&#10;import main.interface_adapter.Property.PropertyViewModel.*;&#10;import main.use_case.Property.PropertyLandingUseCase;&#10;import main.use_case.Property.PropertyLandingUseCase.PurchaseResultCallback;&#10;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;&#10;/**&#10; * BoardView is a JPanel that represents the main view of the game board.&#10; * This is a passive view that delegates business logic to controllers.&#10; * Now implements PropertyViewInterface to receive view models from presenter.&#10; */&#10;public class BoardView extends JPanel implements PropertyViewInterface {&#10;    // Components responsible for specific functionality&#10;    private final Game game;&#10;    private final BoardRenderer boardRenderer;&#10;    private final DiceController diceController;&#10;    private final PlayerMovementAnimator playerMovementAnimator;&#10;    private JFrame parentFrame; // Reference to parent frame for end screen&#10;&#10;    // Controllers, Use Cases, and Presenters following Clean Architecture&#10;    private final PropertyPresenter propertyPresenter;&#10;    private final PropertyLandingUseCase propertyLandingUseCase;&#10;    private final PropertyController propertyController;&#10;&#10;    // ——— Dice UI &amp; state ———&#10;    private final JButton rollDiceButton = new JButton(&quot;Roll Dice&quot;);&#10;    private final JButton endTurnButton = new JButton(&quot;End Turn&quot;);&#10;    private final JButton stockMarketButton = new JButton(&quot;Stock Market&quot;);&#10;    private final JLabel roundLabel = new JLabel(&quot;Round: 1&quot;);&#10;    private final JLabel turnLabel = new JLabel(&quot;Turns: 0&quot;);&#10;&#10;    // player stats&#10;    private final PlayerStatsView statsPanel;&#10;&#10;    public BoardView() {&#10;        this.game = new Game();&#10;        this.diceController = new DiceController();&#10;        this.boardRenderer = new BoardRenderer();&#10;        this.playerMovementAnimator = new PlayerMovementAnimator();&#10;        this.statsPanel = new PlayerStatsView(game.getPlayers());&#10;&#10;        // Initialize Clean Architecture components in proper order&#10;        // Presenter implements output boundary and uses view interface&#10;        this.propertyPresenter = new PropertyPresenter(this);&#10;&#10;        // Use case depends on output boundary (presenter)&#10;        this.propertyLandingUseCase = new PropertyLandingUseCase(propertyPresenter);&#10;&#10;        // Controller depends on use case&#10;        this.propertyController = new PropertyController(propertyLandingUseCase);&#10;&#10;        // Set controller as the landing handler for all property tiles&#10;        setupPropertyLandingHandlers();&#10;&#10;        setPreferredSize(new java.awt.Dimension(Constants.BOARD_PANEL_WIDTH,&#10;                Constants.BOARD_PANEL_HEIGHT));&#10;        setupUI();&#10;    }&#10;&#10;    /**&#10;     * Configure property tiles to use the controller for landing events&#10;     */&#10;    private void setupPropertyLandingHandlers() {&#10;        for (PropertyTile property : game.getTiles()) {&#10;            property.setLandingHandler(propertyController);&#10;        }&#10;    }&#10;&#10;    public void setParentFrame(JFrame parentFrame) {&#10;        this.parentFrame = parentFrame;&#10;    }&#10;&#10;    private void setupUI() {&#10;        setLayout(new BorderLayout());&#10;        setPreferredSize(new Dimension(Constants.BOARD_PANEL_WIDTH, Constants.BOARD_PANEL_HEIGHT));&#10;&#10;        // Create board panel - delegate rendering to BoardRenderer&#10;        JPanel boardPanel = new JPanel() {&#10;            @Override&#10;            protected void paintComponent(Graphics g) {&#10;                super.paintComponent(g);&#10;                boardRenderer.drawBoard(g, game, diceController);&#10;            }&#10;        };&#10;        boardPanel.setPreferredSize(new Dimension(Constants.BOARD_PANEL_WIDTH, Constants.BOARD_PANEL_HEIGHT));&#10;        boardPanel.setBackground(Color.LIGHT_GRAY);&#10;&#10;        add(boardPanel, BorderLayout.WEST);&#10;        add(statsPanel, BorderLayout.CENTER);&#10;&#10;        // Roll-Dice side-panel&#10;        JPanel side = new JPanel();&#10;        side.setLayout(new BoxLayout(side, BoxLayout.Y_AXIS));&#10;&#10;        // Game status labels&#10;        roundLabel.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 16));&#10;        turnLabel.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 16));&#10;        side.add(roundLabel);&#10;        side.add(turnLabel);&#10;        side.add(Box.createVerticalStrut(20));&#10;&#10;        side.add(rollDiceButton);&#10;        side.add(endTurnButton);&#10;        side.add(stockMarketButton);&#10;        add(side, BorderLayout.EAST);&#10;&#10;        // wire the button&#10;        rollDiceButton.addActionListener(e -&gt; handleRollDice());&#10;        endTurnButton.addActionListener(e -&gt; handleEndTurn());&#10;        stockMarketButton.addActionListener(e -&gt; displayStockMarket());&#10;&#10;        updateStatusLabels();&#10;    }&#10;&#10;    /**&#10;     * Delegate stock market display to appropriate component&#10;     */&#10;    private void displayStockMarket() {&#10;        StockMarketView stockMarketView = new StockMarketView(game.getCurrentPlayer());&#10;        stockMarketView.setVisible(true);&#10;    }&#10;&#10;    /**&#10;     * Update game status display&#10;     */&#10;    private void updateStatusLabels() {&#10;        roundLabel.setText(&quot;Round: &quot; + game.getCurrentRound());&#10;        turnLabel.setText(&quot;Turns: &quot; + game.getTotalTurns());&#10;    }&#10;&#10;    /**&#10;     * Handle dice roll - delegate to DiceController&#10;     */&#10;    private void handleRollDice() {&#10;        rollDiceButton.setEnabled(false);&#10;&#10;        // Use DiceController for dice animation and logic&#10;        diceController.startDiceAnimation(&#10;            this::repaint, // Animation frame callback&#10;            this::onDiceRollComplete // Completion callback&#10;        );&#10;    }&#10;&#10;    /**&#10;     * Handle dice roll completion - delegate movement to game logic&#10;     */&#10;    private void onDiceRollComplete() {&#10;        Player currentPlayer = game.getCurrentPlayer();&#10;        int diceSum = diceController.getLastDiceSum();&#10;&#10;        // Handle crossing GO bonus using Game logic&#10;        game.moveCurrentPlayer(diceSum);&#10;&#10;        // Use PlayerMovementAnimator for movement animation&#10;        playerMovementAnimator.animatePlayerMovement(&#10;            currentPlayer,&#10;            diceSum,&#10;            game.getTileCount(),&#10;            this::repaint, // Movement step callback&#10;            this::onPlayerMovementComplete // Completion callback&#10;        );&#10;    }&#10;&#10;    /**&#10;     * Handle player movement completion - delegate to tile logic&#10;     */&#10;    private void onPlayerMovementComplete() {&#10;        handleLandingOnTile();&#10;    }&#10;&#10;    /**&#10;     * Handle landing on tile - delegate to tile's onLanding method&#10;     * The tile will use the appropriate controller (PropertyController for properties)&#10;     */&#10;    private void handleLandingOnTile() {&#10;        Player currentPlayer = game.getCurrentPlayer();&#10;        int position = currentPlayer.getPosition();&#10;        Tile tile = game.getPropertyAt(position);&#10;&#10;        if (tile != null) {&#10;            // Use tile's built-in landing logic which will call the appropriate controller&#10;            tile.onLanding(currentPlayer);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle end turn - delegate to game logic&#10;     */&#10;    private void handleEndTurn() {&#10;        new GameNextTurn(game).execute();&#10;        updateStatusLabels();&#10;        statsPanel.updatePlayers(game.getPlayers());&#10;&#10;        if (game.isGameOver()) {&#10;            showEndScreen();&#10;            return;&#10;        }&#10;&#10;        rollDiceButton.setEnabled(true);&#10;        repaint();&#10;    }&#10;&#10;    /**&#10;     * Show end screen when game is over&#10;     */&#10;    private void showEndScreen() {&#10;        rollDiceButton.setEnabled(false);&#10;        endTurnButton.setEnabled(false);&#10;&#10;        // Hide the parent frame if it exists&#10;        if (parentFrame != null) {&#10;            parentFrame.setVisible(false);&#10;        }&#10;&#10;        // Show the end screen&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            new EndScreen(&#10;                    game.getPlayers(),&#10;                    game.getGameEndReason(),&#10;                    game.getCurrentRound()&#10;            );&#10;        });&#10;    }&#10;&#10;    // Getters for components that need access&#10;    public int getLastDiceSum() {&#10;        return diceController.getLastDiceSum();&#10;    }&#10;&#10;    public Game getGame() {&#10;        return game;&#10;    }&#10;&#10;    /**&#10;     * Get the property presenter for property-specific UI concerns&#10;     */&#10;    public PropertyPresenter getPropertyPresenter() {&#10;        return propertyPresenter;&#10;    }&#10;&#10;    /**&#10;     * Get the property controller for property-related business logic&#10;     */&#10;    public PropertyController getPropertyController() {&#10;        return propertyController;&#10;    }&#10;&#10;    /**&#10;     * Get the property use case for testing purposes&#10;     */&#10;    public PropertyLandingUseCase getPropertyLandingUseCase() {&#10;        return propertyLandingUseCase;&#10;    }&#10;&#10;    /**&#10;     * For Testing the Board View on its own&#10;     */&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            JFrame frame = new JFrame(&quot;Monopoly Board&quot;);&#10;            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;            BoardView boardView = new BoardView();&#10;            boardView.setParentFrame(frame);&#10;            frame.add(boardView);&#10;            frame.pack();&#10;            frame.setLocationRelativeTo(null);&#10;            frame.setVisible(true);&#10;        });&#10;    }&#10;&#10;    // Implementation of PropertyViewInterface&#10;    @Override&#10;    public void showPurchaseDialog(PurchaseDialogViewModel viewModel, PurchaseResultCallback callback) {&#10;        Frame parentFrame = (Frame) SwingUtilities.getWindowAncestor(this);&#10;&#10;        // Find the actual player and property objects for the popup&#10;        Player player = findPlayerByName(viewModel.playerName);&#10;        PropertyTile property = findPropertyByName(viewModel.propertyName);&#10;&#10;        if (player != null &amp;&amp; property != null) {&#10;            BuyPropertyPopup.showPurchaseDialog(parentFrame, player, property,&#10;                    (success, message) -&gt; callback.onResult(success));&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void updateAfterPropertyPurchased(PropertyPurchasedViewModel viewModel) {&#10;        // Update UI after property purchase&#10;        statsPanel.updatePlayers(game.getPlayers());&#10;        repaint(); // Trigger board repaint to show ownership change&#10;    }&#10;&#10;    @Override&#10;    public void showRentPaymentNotification(RentPaymentViewModel viewModel) {&#10;        // Show rent payment notification&#10;        Frame parentFrame = (Frame) SwingUtilities.getWindowAncestor(this);&#10;        showRentNotification(parentFrame, viewModel);&#10;&#10;        // Update UI after rent payment&#10;        statsPanel.updatePlayers(game.getPlayers());&#10;        repaint();&#10;    }&#10;&#10;    // Helper methods for finding entities (needed for legacy popup interface)&#10;    private Player findPlayerByName(String name) {&#10;        return game.getPlayers().stream()&#10;                .filter(p -&gt; p.getName().equals(name))&#10;                .findFirst()&#10;                .orElse(null);&#10;    }&#10;&#10;    private PropertyTile findPropertyByName(String name) {&#10;        return game.getTiles().stream()&#10;                .filter(tile -&gt; tile.getName().equals(name))&#10;                .findFirst()&#10;                .orElse(null);&#10;    }&#10;&#10;    /**&#10;     * Shows rent payment notification dialog using view model data&#10;     */&#10;    private void showRentNotification(Frame parent, RentPaymentViewModel viewModel) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            String message = viewModel.payerName + &quot; paid $&quot; + (int) viewModel.rentAmount +&#10;                    &quot; rent to &quot; + viewModel.ownerName + &quot; for landing on &quot; + viewModel.propertyName;&#10;&#10;            JOptionPane.showMessageDialog(&#10;                    parent,&#10;                    message,&#10;                    &quot;Rent Payment&quot;,&#10;                    JOptionPane.INFORMATION_MESSAGE&#10;            );&#10;        });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package main.view;&#10;&#10;import main.entity.tiles.PropertyTile;&#10;import main.entity.players.Player;&#10;import main.entity.*;&#10;import main.use_case.Game.GameNextTurn;&#10;import main.Constants.Constants;&#10;import main.use_case.Tile;&#10;import main.interface_adapter.Property.PropertyController;&#10;import main.interface_adapter.Property.PropertyPresenter;&#10;import main.interface_adapter.Property.PropertyViewModel.*;&#10;import main.use_case.Property.PropertyLandingUseCase;&#10;import main.use_case.Property.PropertyLandingUseCase.PurchaseResultCallback;&#10;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;&#10;/**&#10; * BoardView is a JPanel that represents the main view of the game board.&#10; * This is a passive view that delegates business logic to controllers.&#10; */&#10;public class BoardView extends JPanel {&#10;    // Components responsible for specific functionality&#10;    private final Game game;&#10;    private final BoardRenderer boardRenderer;&#10;    private final DiceController diceController;&#10;    private final PlayerMovementAnimator playerMovementAnimator;&#10;    private JFrame parentFrame; // Reference to parent frame for end screen&#10;&#10;    // Controllers, Use Cases, and Presenters following Clean Architecture&#10;    private final PropertyPresenter propertyPresenter;&#10;    private final PropertyLandingUseCase propertyLandingUseCase;&#10;    private final PropertyController propertyController;&#10;&#10;    // ——— Dice UI &amp; state ———&#10;    private final JButton rollDiceButton = new JButton(&quot;Roll Dice&quot;);&#10;    private final JButton endTurnButton = new JButton(&quot;End Turn&quot;);&#10;    private final JButton stockMarketButton = new JButton(&quot;Stock Market&quot;);&#10;    private final JLabel roundLabel = new JLabel(&quot;Round: 1&quot;);&#10;    private final JLabel turnLabel = new JLabel(&quot;Turns: 0&quot;);&#10;&#10;    // player stats&#10;    private final PlayerStatsView statsPanel;&#10;&#10;    public BoardView() {&#10;        this.game = new Game();&#10;        this.diceController = new DiceController();&#10;        this.boardRenderer = new BoardRenderer();&#10;        this.playerMovementAnimator = new PlayerMovementAnimator();&#10;        this.statsPanel = new PlayerStatsView(game.getPlayers());&#10;&#10;        // Initialize Clean Architecture components in proper order&#10;        // Presenter implements output boundary and uses BoardView directly&#10;        this.propertyPresenter = new PropertyPresenter(this);&#10;&#10;        // Use case depends on output boundary (presenter)&#10;        this.propertyLandingUseCase = new PropertyLandingUseCase(propertyPresenter);&#10;&#10;        // Controller depends on use case&#10;        this.propertyController = new PropertyController(propertyLandingUseCase);&#10;&#10;        // Set controller as the landing handler for all property tiles&#10;        setupPropertyLandingHandlers();&#10;&#10;        setPreferredSize(new java.awt.Dimension(Constants.BOARD_PANEL_WIDTH,&#10;                Constants.BOARD_PANEL_HEIGHT));&#10;        setupUI();&#10;    }&#10;&#10;    /**&#10;     * Configure property tiles to use the controller for landing events&#10;     */&#10;    private void setupPropertyLandingHandlers() {&#10;        for (PropertyTile property : game.getTiles()) {&#10;            property.setLandingHandler(propertyController);&#10;        }&#10;    }&#10;&#10;    public void setParentFrame(JFrame parentFrame) {&#10;        this.parentFrame = parentFrame;&#10;    }&#10;&#10;    private void setupUI() {&#10;        setLayout(new BorderLayout());&#10;        setPreferredSize(new Dimension(Constants.BOARD_PANEL_WIDTH, Constants.BOARD_PANEL_HEIGHT));&#10;&#10;        // Create board panel - delegate rendering to BoardRenderer&#10;        JPanel boardPanel = new JPanel() {&#10;            @Override&#10;            protected void paintComponent(Graphics g) {&#10;                super.paintComponent(g);&#10;                boardRenderer.drawBoard(g, game, diceController);&#10;            }&#10;        };&#10;        boardPanel.setPreferredSize(new Dimension(Constants.BOARD_PANEL_WIDTH, Constants.BOARD_PANEL_HEIGHT));&#10;        boardPanel.setBackground(Color.LIGHT_GRAY);&#10;&#10;        add(boardPanel, BorderLayout.WEST);&#10;        add(statsPanel, BorderLayout.CENTER);&#10;&#10;        // Roll-Dice side-panel&#10;        JPanel side = new JPanel();&#10;        side.setLayout(new BoxLayout(side, BoxLayout.Y_AXIS));&#10;&#10;        // Game status labels&#10;        roundLabel.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 16));&#10;        turnLabel.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 16));&#10;        side.add(roundLabel);&#10;        side.add(turnLabel);&#10;        side.add(Box.createVerticalStrut(20));&#10;&#10;        side.add(rollDiceButton);&#10;        side.add(endTurnButton);&#10;        side.add(stockMarketButton);&#10;        add(side, BorderLayout.EAST);&#10;&#10;        // wire the button&#10;        rollDiceButton.addActionListener(e -&gt; handleRollDice());&#10;        endTurnButton.addActionListener(e -&gt; handleEndTurn());&#10;        stockMarketButton.addActionListener(e -&gt; displayStockMarket());&#10;&#10;        updateStatusLabels();&#10;    }&#10;&#10;    /**&#10;     * Delegate stock market display to appropriate component&#10;     */&#10;    private void displayStockMarket() {&#10;        StockMarketView stockMarketView = new StockMarketView(game.getCurrentPlayer());&#10;        stockMarketView.setVisible(true);&#10;    }&#10;&#10;    /**&#10;     * Update game status display&#10;     */&#10;    private void updateStatusLabels() {&#10;        roundLabel.setText(&quot;Round: &quot; + game.getCurrentRound());&#10;        turnLabel.setText(&quot;Turns: &quot; + game.getTotalTurns());&#10;    }&#10;&#10;    /**&#10;     * Handle dice roll - delegate to DiceController&#10;     */&#10;    private void handleRollDice() {&#10;        rollDiceButton.setEnabled(false);&#10;&#10;        // Use DiceController for dice animation and logic&#10;        diceController.startDiceAnimation(&#10;            this::repaint, // Animation frame callback&#10;            this::onDiceRollComplete // Completion callback&#10;        );&#10;    }&#10;&#10;    /**&#10;     * Handle dice roll completion - delegate movement to game logic&#10;     */&#10;    private void onDiceRollComplete() {&#10;        Player currentPlayer = game.getCurrentPlayer();&#10;        int diceSum = diceController.getLastDiceSum();&#10;&#10;        // Handle crossing GO bonus using Game logic&#10;        game.moveCurrentPlayer(diceSum);&#10;&#10;        // Use PlayerMovementAnimator for movement animation&#10;        playerMovementAnimator.animatePlayerMovement(&#10;            currentPlayer,&#10;            diceSum,&#10;            game.getTileCount(),&#10;            this::repaint, // Movement step callback&#10;            this::onPlayerMovementComplete // Completion callback&#10;        );&#10;    }&#10;&#10;    /**&#10;     * Handle player movement completion - delegate to tile logic&#10;     */&#10;    private void onPlayerMovementComplete() {&#10;        handleLandingOnTile();&#10;    }&#10;&#10;    /**&#10;     * Handle landing on tile - delegate to tile's onLanding method&#10;     * The tile will use the appropriate controller (PropertyController for properties)&#10;     */&#10;    private void handleLandingOnTile() {&#10;        Player currentPlayer = game.getCurrentPlayer();&#10;        int position = currentPlayer.getPosition();&#10;        Tile tile = game.getPropertyAt(position);&#10;&#10;        if (tile != null) {&#10;            // Use tile's built-in landing logic which will call the appropriate controller&#10;            tile.onLanding(currentPlayer);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle end turn - delegate to game logic&#10;     */&#10;    private void handleEndTurn() {&#10;        new GameNextTurn(game).execute();&#10;        updateStatusLabels();&#10;        statsPanel.updatePlayers(game.getPlayers());&#10;&#10;        if (game.isGameOver()) {&#10;            showEndScreen();&#10;            return;&#10;        }&#10;&#10;        rollDiceButton.setEnabled(true);&#10;        repaint();&#10;    }&#10;&#10;    /**&#10;     * Show end screen when game is over&#10;     */&#10;    private void showEndScreen() {&#10;        rollDiceButton.setEnabled(false);&#10;        endTurnButton.setEnabled(false);&#10;&#10;        // Hide the parent frame if it exists&#10;        if (parentFrame != null) {&#10;            parentFrame.setVisible(false);&#10;        }&#10;&#10;        // Show the end screen&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            new EndScreen(&#10;                    game.getPlayers(),&#10;                    game.getGameEndReason(),&#10;                    game.getCurrentRound()&#10;            );&#10;        });&#10;    }&#10;&#10;    // Getters for components that need access&#10;    public int getLastDiceSum() {&#10;        return diceController.getLastDiceSum();&#10;    }&#10;&#10;    public Game getGame() {&#10;        return game;&#10;    }&#10;&#10;    /**&#10;     * Get the property presenter for property-specific UI concerns&#10;     */&#10;    public PropertyPresenter getPropertyPresenter() {&#10;        return propertyPresenter;&#10;    }&#10;&#10;    /**&#10;     * Get the property controller for property-related business logic&#10;     */&#10;    public PropertyController getPropertyController() {&#10;        return propertyController;&#10;    }&#10;&#10;    /**&#10;     * Get the property use case for testing purposes&#10;     */&#10;    public PropertyLandingUseCase getPropertyLandingUseCase() {&#10;        return propertyLandingUseCase;&#10;    }&#10;&#10;    /**&#10;     * For Testing the Board View on its own&#10;     */&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            JFrame frame = new JFrame(&quot;Monopoly Board&quot;);&#10;            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;            BoardView boardView = new BoardView();&#10;            boardView.setParentFrame(frame);&#10;            frame.add(boardView);&#10;            frame.pack();&#10;            frame.setLocationRelativeTo(null);&#10;            frame.setVisible(true);&#10;        });&#10;    }&#10;&#10;    // Property-related view methods (no longer implementing interface)&#10;    public void showPurchaseDialog(PurchaseDialogViewModel viewModel, PurchaseResultCallback callback) {&#10;        Frame parentFrame = (Frame) SwingUtilities.getWindowAncestor(this);&#10;&#10;        // Find the actual player and property objects for the popup&#10;        Player player = findPlayerByName(viewModel.playerName);&#10;        PropertyTile property = findPropertyByName(viewModel.propertyName);&#10;&#10;        if (player != null &amp;&amp; property != null) {&#10;            BuyPropertyPopup.showPurchaseDialog(parentFrame, player, property,&#10;                    (success, message) -&gt; callback.onResult(success));&#10;        }&#10;    }&#10;&#10;    public void updateAfterPropertyPurchased(PropertyPurchasedViewModel viewModel) {&#10;        // Update UI after property purchase&#10;        statsPanel.updatePlayers(game.getPlayers());&#10;        repaint(); // Trigger board repaint to show ownership change&#10;    }&#10;&#10;    public void showRentPaymentNotification(RentPaymentViewModel viewModel) {&#10;        // Show rent payment notification&#10;        Frame parentFrame = (Frame) SwingUtilities.getWindowAncestor(this);&#10;        showRentNotification(parentFrame, viewModel);&#10;&#10;        // Update UI after rent payment&#10;        statsPanel.updatePlayers(game.getPlayers());&#10;        repaint();&#10;    }&#10;&#10;    // Helper methods for finding entities (needed for legacy popup interface)&#10;    private Player findPlayerByName(String name) {&#10;        return game.getPlayers().stream()&#10;                .filter(p -&gt; p.getName().equals(name))&#10;                .findFirst()&#10;                .orElse(null);&#10;    }&#10;&#10;    private PropertyTile findPropertyByName(String name) {&#10;        return game.getTiles().stream()&#10;                .filter(tile -&gt; tile.getName().equals(name))&#10;                .findFirst()&#10;                .orElse(null);&#10;    }&#10;&#10;    /**&#10;     * Shows rent payment notification dialog using view model data&#10;     */&#10;    private void showRentNotification(Frame parent, RentPaymentViewModel viewModel) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            String message = viewModel.payerName + &quot; paid $&quot; + (int) viewModel.rentAmount +&#10;                    &quot; rent to &quot; + viewModel.ownerName + &quot; for landing on &quot; + viewModel.propertyName;&#10;&#10;            JOptionPane.showMessageDialog(&#10;                    parent,&#10;                    message,&#10;                    &quot;Rent Payment&quot;,&#10;                    JOptionPane.INFORMATION_MESSAGE&#10;            );&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>